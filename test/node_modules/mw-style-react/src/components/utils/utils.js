import sanitizeHtml from 'sanitize-html';

/**
 * Utils
 */
const Utils = {

  createRequestTypes(base) {
    const REQUEST = 'REQUEST';
    const SUCCESS = 'SUCCESS';
    const FAILURE = 'FAILURE';
    return [REQUEST, SUCCESS, FAILURE].reduce((acc, type) => {
      acc[type] = `${base}_${type}`;
      return acc;
    }, {});
  },

  random() {
    return Math.floor(Math.random() * 0xFFFF);
  },

  tryToBool(str) {
    if (str === 'false') return false;
    if (str === 'true') return true;
    return str;
  },

  toPascalCase(str) {
    if (!str) return;
    let arr = str.split('_');
    arr = arr.map(i => (
      this.toUpperLatter(i.toLocaleLowerCase())
    ));
    return arr.join('');
  },

  range(min, max) {
    const list = [];
    for (let i = min; i <= max; i += 1) {
      list.push(i);
    }
    return list;
  },

  // function to animate scroll
  scrollTo(element, to, duration, animationType) {
    const start = element.scrollTop;
    const change = to - start;
    let currentTime = 0;
    const increment = 20;
    const easeInOutQuad = (t, b, c, d) => {
      t /= d / 2;
      if (t < 1) return c / 2 * t * t + b;
      t -= 1;
      return -c / 2 * (t * (t - 2) - 1) + b;
    };
    const linearTween = (t, b, c, d) => (c * t / d + b);
    const animateScroll = () => {
      currentTime += increment;
      let value;
      switch (animationType) {
        case 'easeInOutQuad':
          value = easeInOutQuad(currentTime, start, change, duration);
          break;
        default:
          value = linearTween(currentTime, start, change, duration);
          break;
      }
      element.scrollTop = value;
      if (currentTime < duration) {
        setTimeout(animateScroll, increment);
      }
    };
    animateScroll();
  },

  // Перевести строку в CamelCase из underscore стиля
  toCamelCase(str, firstUpper) {
    const camelCase = str.replace(/_([a-z])/g, (m, w) => w.toUpperCase());
    if (!firstUpper) return camelCase;
    return camelCase.charAt(0).toUpperCase() + camelCase.slice(1);
  },

  toUnderscoreCase(str) {
    return str.split(/(?=[A-Z])/).join('_').toLowerCase();
  },

  // Перевести  CamelCase в  CONSTANT_CASE
  toConstantCase(str) {
    return str.split(/(?=[A-Z])/).join('_').toUpperCase();
  },

  // Перевести первую букву в верхний регистр
  toUpperLatter(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  },

  // Сделать заглавной первую букву
  capitalize(str) {
    if (!str) return;
    const s = str.toLocaleLowerCase();
    return this.toUpperLatter(s);
  },

  toStorage(key, value) {
    if (this.isLocalStorageSupported()) {
      window.localStorage.setItem(key, value);
    }
  },

  fromStorage(key) {
    if (this.isLocalStorageSupported()) {
      return window.localStorage.getItem(key);
    }
  },

  delStorage(key) {
    if (this.isLocalStorageSupported()) {
      return window.localStorage.removeItem(key);
    }
  },

  toSessionStorage(key, value) {
    if (this.isLocalStorageSupported()) {
      window.sessionStorage.setItem(key, value);
    }
  },

  fromSessionStorage(key) {
    if (this.isLocalStorageSupported()) {
      return window.sessionStorage.getItem(key);
    }
  },

  delSessionStorage(key) {
    if (this.isLocalStorageSupported()) {
      return window.sessionStorage.removeItem(key);
    }
  },

  // Проверка работает ли LocalStorage
  isLocalStorageSupported() {
    const testKey = 'testWULS';
    const storage = window.sessionStorage;
    try {
      storage.setItem(testKey, '1');
      storage.removeItem(testKey);
      return true;
    } catch (error) {
      return false;
    }
  },

  // Преобразовать объект в url строку
  serialize(params = {}) {
    const str = [];
    Object.keys(params).forEach((p) => {
      if (params[p]) {
        str.push(`${encodeURIComponent(p)}=${encodeURIComponent(params[p])}`);
      }
    });
    return str.join('&');
  },

  // Удалить объект из массива
  removeObjFormArray(arr, field, val) {
    return arr.filter(i => i[field] !== val);
  },

  // Сортировка массима объектов по полю
  sort(arr, field, type = 'ask') {
    return arr.sort((a, b) => {
      if (a[field] > b[field]) return (type === 'ask') ? 1 : -1;
      if (a[field] < b[field]) return (type === 'ask') ? -1 : 1;
      return 0;
    });
  },

  // Получить GET параметры в виде объекта
  getQueryParam(url) {
    if (!url) return {};
    const r = /^.*\?(.+)$/;
    const get = url.replace(r, '$1');
    const split = get.split('&');
    if (split[0] === url) return {};
    const mapGet = split
      .reduce((acc, el) => {
        const spEl = el.split('=');
        acc[decodeURIComponent(spEl[0])] = decodeURIComponent(spEl[1]);
        return acc;
      }, {});
    return mapGet;
  },

  // Экранируем html
  stripHtml(str, allowedTags) {
    if (!str) return '';
    const tagsToReplace = {
      '<': '&lt;',
      '>': '&gt;'
    };
    str = str.replace(/[<>]/g, (tag) => tagsToReplace[tag] || tag);

    if (allowedTags) {
      allowedTags.forEach((tag) => {
        const re1 = new RegExp(`&lt;${tag}&gt;`, 'gi');
        const re2 = new RegExp(`&lt;/${tag}&gt;`, 'gi');
        str = str
          .replace(re1, `<${tag}>`)
          .replace(re2, `</${tag}>`);
      });
    }
    return str;
  },

  // Убираем html теги из строки
  removeHtmlTags(str) {
    str = str || '';
    return str.replace(/<[^>]*>/g, '');
  },

  // Конвертируем bbcode в html
  bbCodeToHtml(text = '') {
    text = this.stripHtml(text);
    const rB = /\[b\](.*?)\[\/b\]/ig;
    const rUrl = /\[url=(.*?)\](.*?)\[\/url\]/ig;
    const rIUrl = /\[iurl=(.*?)\](.*?)\[\/iurl\]/ig;
    const rSize = /\[size=(.*?)\](.*?)\[\/size\]/ig;
    const rColor = /\[color=(.*?)\](.*?)\[\/color\]/ig;
    const rBg = /\[bg=(.*?)\](.*?)\[\/bg\]/ig;
    const rP = /\[p\](.*?)\[\/p\]/ig;
    const rSup = /\[sup\](.*?)\[\/sup\]/ig;
    const rBr = /\[br\]/ig;
    const rUl = /\[ul\](.*?)\[\/ul\]/ig;
    const rLi = /\[\*\](.*?)\[\/\*\]/ig;
    text = text
      .replace(rB, '<b>$1</b>')
      .replace(rUrl, '<a href="$1" target="_blank" rel="noopener noreferrer">$2</a>')
      .replace(rIUrl, '<a href="$1">$2</a>')
      .replace(rP, '<p>$1</p>')
      .replace(rSup, '<sup>$1</sup>')
      .replace(rBr, '<br/>')
      .replace(rUl, '<ul>$1</ul>')
      .replace(rLi, '<li>$1</li>')
      .replace(rSize, '<span style="font-size:$1px">$2</span>')
      .replace(rColor, '<span style="color:$1">$2</span>')
      .replace(rBg, '<span style="background-color:$1">$2</span>');

    return text;
  },

  debounce(f, ms) {
    let timer = null;
    return (...args) => {
      const onComplete = () => {
        f.apply(this, args);
        timer = null;
      };
      if (timer) {
        clearTimeout(timer);
      }
      timer = setTimeout(onComplete, ms);
    };
  },

  throttle(fn, wait) {
    let time = Date.now();
    return (...args) => {
      if ((time + wait - Date.now()) < 0) {
        fn.apply(this, args);
        time = Date.now();
      }
    };
  },

  // Нотификация в браузере
  browserNotify({title, icon, body, link}) {
    if (Notification.permission !== 'granted') {
      Notification.requestPermission();
    } else {
      const notification = new Notification(title, {
        icon,
        body,
      });
      if (link) {
        notification.onclick = () => {
          window.open(link);
        };
      }
    }
  },

  brToN(str) {
    const re = new RegExp('<br>', 'gi');
    const re1 = new RegExp('&nbsp;', 'gi');
    const tSpan = /\<span(.*?)\>(.*?)\<\/span\>/ig; // eslint-disable-line no-useless-escape
    const tDiv = /\<div\>(.*?)\<\/div\>/ig; // eslint-disable-line no-useless-escape
    const tP = /\<p\>(.*?)\<\/p\>/ig; // eslint-disable-line no-useless-escape

    return str
      .replace(re, '\n')
      .replace(re1, ' ')
      .replace(tSpan, '[span$1]$2[/span]')
      .replace(tDiv, '\n$1')
      .replace(tP, '\n$1');
  },

  nToBr(str) {
    const re = new RegExp('\n', 'gi'); // eslint-disable-line no-control-regex
    const tSpan = /\[span(.*?)\](.*?)\[\/span\]/ig;
    return str
      .replace(re, '<br>')
      .replace(tSpan, '<span$1>$2</span>');
  },

  splitText(str, countSymbols) {
    const numChunks = Math.ceil(str.length / countSymbols);
    const chunks = new Array(numChunks);
    /*eslint-disable */
    for (let i = 0, j = 0; i < numChunks; ++i, j += countSymbols) {
      chunks[i] = str.substr(j, countSymbols);
    }
    return chunks;
  },

  uniqArrayOfObjects(arr, uniqField) {
    return arr.filter((item, index, self) =>
      index === self.findIndex((t) => (
        t[uniqField] === item[uniqField]
      ))
    );
  },

  max(arr, field) {
    return Math.max(...arr.map((obj) => obj[field]));
  },

  min(arr, field) {
    return Math.min(...arr.map((obj) => obj[field]));
  },

  sanitizeHtml(str) {
    return sanitizeHtml(str, {
      allowedTags: ['div', 'p', 'span', 'a', 'img', 'br'],
      selfClosing: ['img', 'br'],
      allowedAttributes: {
        img: ['src', 'id', 'alt'],
        span: ['class']
      },
    })
  }
};

export default Utils;
