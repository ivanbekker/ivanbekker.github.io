import PropTypes from 'prop-types';
import React, {PureComponent} from 'react';
import injectSheet from 'react-jss';
import cn from 'clsx';
import enhanceWithClickOutside from 'react-click-outside';
import ReactStars from 'react-stars';
import ReactDOM from 'react-dom';
import emojiRegex from '../utils/emojiRegex';
import Emoji from '../Emoji';
import Button from '../Button';
import Upload from '../Upload';
import TextField from '../TextField';
import Menu from '../Menu';
import AutocompleteItem from '../Autocomplete/AutocompleteItem';
import Chip from '../Chip';
import Icon from '../Icon';
import Utils from '../utils/utils';
import Cursor from '../utils/cursor';
import forwardRef from '../HOC/forwardRef';
import styles from './SendForm.style';

const ForwardTextField = forwardRef(TextField);


@injectSheet(styles)
@enhanceWithClickOutside
class SendForm extends PureComponent {

  constructor(props) {
    super(props);
    this.state = {
      showUsers: false,
      findUserMode: false,
      searchQuery: null,
      userList: null,
      focus: false,
      activeUserItem: 0
    };
    this.selectUser = ::this.selectUser;
    this.hideUsers = ::this.hideUsers;
    this.showUsers = ::this.showUsers;
    this.mouseMoveUsers = ::this.mouseMoveUsers;
    this.handleChange = ::this.handleChange;
    this.handleSubmit = ::this.handleSubmit;
    this.handleKeyDown = ::this.handleKeyDown;
    this.handleKeyUp = ::this.handleKeyUp;
    this._saveCursorPosition = ::this._saveCursorPosition;
    this.selectEmoji = ::this.selectEmoji;
    this.handleFocus = ::this.handleFocus;
    // начальная позиция курсора
    this.cursorPosition = 0;
    this.portalEl = document.createElement('div');
    this.portalEl.id = `${props.id}_filePreview`;
  }

  componentWillMount() {
    this._isMounted = true;
    const {forwardRef} = this.props;
    this.refEdit = forwardRef || React.createRef();
  }

  componentDidMount() {
    this.controls.parentNode.insertBefore(this.portalEl, this.controls);
    this.messageFormatting();
  }

  componentWillUnmount() {
    this._isMounted = false;
  }

  // Сохранить текущую позицию курсора
  _saveCursorPosition() {
    const pos = Cursor.getCaretPosition(this.refEdit.current);
    if (pos !== -1) {
      this.cursorPosition = pos;
    }
  }

  // Установить курсор в заданую позицию
  _setCursor(position) {
    setTimeout(() => {
      this.sendForm.click();
      this.refEdit.current.focus();
      if (position === 'end') {
        Cursor.moveCursorToEnd(this.refEdit.current);
        this._saveCursorPosition();
      } else {
        this.cursorPosition = position;
        Cursor.moveCursorToPosition(this.refEdit.current, this.cursorPosition);
      }
    }, 0);
  }

  // Форматирование комментария
  messageFormatting() {
    const {value} = this.props;
    const regBr = new RegExp('<br>', 'gi');
    const regSpan = new RegExp('\\<span.*?\\>(.*?)\\<\\/span\\>', 'g');
    const regSpan1 = new RegExp('\\[span.*?\\](.*?)\\[\\/span\\]', 'g');
    const sourceMessage = value.message
      .replace(regBr, '\n')
      .replace(regSpan, '$1')
      .replace(regSpan1, '$1');
    const {message, users} = this.highlightAttachments(sourceMessage);
    if (value.message !== message) {
      this.handleChange([
        {id: 'message', value: message, error: false},
        {id: 'users', value: users, error: false}
      ]);
      this._setCursor('end');
    }
  }

  // Обработка клика за пределами компонента
  handleClickOutside() {
    this.setState({findUserMode: false, focus: false});
    this.hideUsers();
  }

  // Обработчик при отправке формы
  handleSubmit() {
    const {id, value, error, onSubmit} = this.props;
    const {showUsers} = this.state;
    if (showUsers) return;
    const formatValue = this.formatAndCheck(value);
    onSubmit({id, value: formatValue, error});
  }

  // Format values on submit
  formatAndCheck(value) {
    return {
      ...value,
      message: Utils.brToN(value.message),
      users: Utils.uniqArrayOfObjects(value.users || [], 'id'),
      sign: value.sign,
      rating: value.rating
    };
  }

  // Handle change message and files
  handleChange(e) {
    e = Array.isArray(e) ? e : [e];
    const {id, value, onChange} = this.props;
    const newValue = {...value};
    let error = false;
    e.forEach((el) => {
      newValue[el.id] = el.value;
      error = error || el.error;
    });
    onChange({id, value: newValue, error});
  }

  handleKeyDown(e) {
    const {onKeyDown, type} = this.props;
    const {showUsers} = this.state;
    const metaKey = e.metaKey || e.ctrlKey;
    const isEnter = e.key === 'Enter';
    const hotKeysManage = ['ArrowDown', 'ArrowUp', 'Enter'];
    // Если зажат ctrl или command, то делаем перенос строки,
    // иначе по enter отправляем форму
    if (!metaKey && isEnter && !this.state.findUserMode && type === 'chat' ||
      metaKey && isEnter && !this.state.findUserMode && type === 'comment') {
      e.preventDefault();
      this.handleSubmit();
    } else if (metaKey && isEnter && type === 'chat' || isEnter && type === 'comment') {
      Cursor.fixLineBreak(e);
    }
    // Навигация по списку пользователей
    if (showUsers && hotKeysManage.includes(e.key)) {
      this.selectUserUsingButtons(e);
    }
    onKeyDown(e);
  }

  handleKeyUp(e) {
    const {onKeyUp} = this.props;
    this._saveCursorPosition();
    this.setUsersQueryReq(e.key);
    this.searchUsersQueryReq(e.key);
    if (e.key === ' ' || e.key === 'Backspace') {
      this.messageFormatting();
    }
    onKeyUp(e);
  }

  handleFocus() {
    this.setState({focus: true});
  }

  // Устанавливаем поисковый запрос пользователя,
  // если в строке комментария был нажат символ @
  setUsersQueryReq(key) {
    // Игнорируем нажатие на Ctrl, Shift...
    if (key.length > 1) return;
    if (key === '@') {
      this.showUsers();
      this.setState({findUserMode: true});
      return;
    }
    const {findUserMode, searchQuery} = this.state;
    const {options} = this.props;
    const users = options.users;
    if (!findUserMode || !users) return;
    let newSearchQuery = (searchQuery) ? searchQuery + key : key;
    newSearchQuery = newSearchQuery.toLowerCase();
    const userList = users.filter((user) =>
      user.value.toLowerCase().indexOf(newSearchQuery) !== -1
    );
    if (!userList.length) {
      this.hideUsers();
    } else {
      this.setState({searchQuery: newSearchQuery, userList});
    }
  }

  // Скролл по списку пользователей
  scrollUserList(item) {
    const container = ReactDOM.findDOMNode(this.containerUsersList);
    const heightContainer = container.offsetHeight;
    const heightItem = item.offsetHeight;
    const scrollPosition =
      item.offsetTop < (heightContainer - (heightItem * 3)) ?
        0 :
        item.offsetTop - (heightContainer - (heightItem * 3));

    Utils.scrollTo(container, scrollPosition, 100);
  }

  // Поиск в строке комментария поисковой строки пользователя
  // при нажати кнопки Backspace
  searchUsersQueryReq(key) {
    const {value, options} = this.props;
    if (key !== 'Backspace') return;
    const message = value.message;
    const users = options.users || [];
    const clearMessage = this.makeClearMessage(message);
    const leftPart = clearMessage.substring(0, this.cursorPosition);
    const splitLeftPart = leftPart.split('@');
    const query = splitLeftPart[splitLeftPart.length - 1];
    const userList = users.filter((user) =>
      user.value.toLowerCase().indexOf(query.toLowerCase()) !== -1
    );
    const lastDog = leftPart.charAt(leftPart.length - 1);
    if (userList.length && (query.length || lastDog === '@')) {
      this.setState({
        showUsers: true,
        findUserMode: true,
        searchQuery: query,
        userList
      });
    } else {
      this.hideUsers();
    }
  }

  // Выбрать смайлик
  selectEmoji(emoji) {
    const smile = String.fromCodePoint(parseInt(emoji.unified, 16));
    this.insertAttachment('smile', `${smile} `);
  }

  // Показать список пользователей
  showUsers() {
    this.setState({showUsers: true});
    this.refEdit.current.focus();
    Cursor.moveCursorToPosition(this.refEdit.current, this.cursorPosition);
  }

  // Скрыть список пользователей
  hideUsers() {
    this.setState({
      showUsers: false,
      findUserMode: false,
      searchQuery: null,
      activeUserItem: 0,
    });
    // Задержка обнуления пользователей для плавной анимации скрытия
    // списка пользователей
    setTimeout(() => {
      if (!this._isMounted) return;
      this.setState({userList: null});
    }, 500);
  }

  // Движение мышкой по спику пользователей. Сбрасываем индекс активного пользователя
  mouseMoveUsers() {
    this.setState({activeUserItem: -1});
  }

  // Выбрать пользователя по навигации стрелочек
  selectUserUsingButtons(e) {
    e.preventDefault();
    const {showUsers, userList, activeUserItem} = this.state;
    const {options} = this.props;
    const users = userList || options.users;
    if (!showUsers) return;

    let newActiveItem = activeUserItem;

    if (e.key === 'ArrowDown' && activeUserItem < users.length - 1) {
      newActiveItem += 1;
    } else if (e.key === 'ArrowUp' && activeUserItem > 0) {
      newActiveItem -= 1;
    }
    if (!users[newActiveItem]) return;
    const item = this[`itemRef${newActiveItem}`];
    if (e.key === 'Enter') {
      this.selectUser({value: item.props});
      newActiveItem = 0;
    }
    this.setState({
      activeUserItem: newActiveItem
    }, this.scrollUserList(ReactDOM.findDOMNode(item)));
  }

  // Выбрать пользователя из списка
  selectUser({value: vItem}) {
    const userStr = `@${vItem.value} `;
    this.insertAttachment('user', userStr);
  }

  // Вставить вложение в текст комментария по позиции курсора
  insertAttachment(type, attachment) {
    const {value} = this.props;
    const clearMessage = this.makeClearMessage(value.message);
    const matchLieBreak = clearMessage.match(/\n/g);
    const lineBreakLen = matchLieBreak ? matchLieBreak.length : 0;
    const cursorPos = this.cursorPosition + lineBreakLen;
    const firstPart = clearMessage.substring(0, cursorPos);
    const lastPart = clearMessage.substring(cursorPos);
    const fix = this.replaceSearchReq(type, firstPart, lastPart);
    const newMessage = `${fix.firstPart}${attachment}${fix.lastPart}`;
    const {message, users} = this.highlightAttachments(newMessage);
    this.handleChange([
      {id: 'message', value: message, error: false},
      {id: 'users', value: users, error: false}
    ]);
    this._setCursor(`${fix.firstPart}${attachment}`.length - lineBreakLen);
  }

  // Удалить поисковый запрос пользователя из строки комментария
  // при выборке пользователя из выпадающего списка
  replaceSearchReq(type, firstPart, lastPart) {
    const {searchQuery, findUserMode} = this.state;
    if (type !== 'user' || !findUserMode) return {firstPart, lastPart};
    const lastIndexOf = firstPart.lastIndexOf(`@${searchQuery || ''}`);
    const fixFirstPart = firstPart.substring(0, lastIndexOf);
    return {firstPart: fixFirstPart, lastPart};
  }

  // Удаляем из строки комментария все html теги.
  makeClearMessage(sourceMessage) {
    const regBr = new RegExp('<br>', 'gi');
    const regSpan = new RegExp('\\<span.*?\\>(.*?)\\<\\/span\\>\\&nbsp\\;', 'g');
    return sourceMessage
      .replace(regBr, '\n')
      .replace(regSpan, '$1 ');
  }

  // Парсинг строки комментария, выделяем смайлики и пользователей
  highlightAttachments(sourceMessage) {
    const {options} = this.props;
    const users = options.users || [];
    let message;
    // Преобразовываем переносы строк
    const regBr = new RegExp('\n', 'gi'); // eslint-disable-line no-control-regex
    message = sourceMessage.replace(regBr, '<br>');
    // Оборачиваем все смайлики в span
    let match;
    const regex = emojiRegex;
    while (match = regex.exec(sourceMessage)) { // eslint-disable-line no-cond-assign
      const emoji = match[0];
      message = message
        .replace(`${emoji} `, `<span class="emoji">${emoji}</span>&nbsp;`);
    }
    // Оборачиваем упоминания пользователей в span
    const foundUsers = [];
    users.forEach((user) => {
      const nick = user.value;
      const copyMessage = message;
      const reg = new RegExp(`\\@${nick}(\\&nbsp\\;|\\s){1,}`, 'gim');
      message = message
        .replace(reg, `<span class="user">@${nick}</span>&nbsp;`);
      // Если строка изменилась, то сохраняем пользователя
      if (message !== copyMessage) {
        foundUsers.push(user);
      }
    });
    return {message, users: foundUsers};
  }

  // Показать попап со списком пользователей
  renderUsers() {
    const {options, classes} = this.props;
    const {showUsers, userList, activeUserItem} = this.state;
    if (!options.users) return null;
    const users = userList || options.users;
    const activeItem = (users[activeUserItem]) ? users[activeUserItem].id : null;
    return (
      <Menu
        ref={(el) => {
          this.containerUsersList = el;
        }}
        id="users"
        type="slaveMenu"
        className={classes.usersList}
        visibility={showUsers ? 'visible' : 'hidden'}
        onClick={this.selectUser}
        onClose={this.hideUsers}
        onMouseMove={this.mouseMoveUsers}
      >
        {users.map((i, index) => (
          <AutocompleteItem
            ref={(el) => {
              this[`itemRef${index}`] = el;
            }}
            key={i.id}
            size="medium"
            activeItem={activeItem}
            {...i}
          />
        ))}
      </Menu>
    );
  }

  renderSign() {
    return (<Chip
      label="Signed"
      type="rectangular"
      icon="sign"
      closeClick={() => this.handleChange({id: 'sign', value: false})}
    />);
  }

  renderRate(value) {
    const {classes} = this.props;
    return (
      <Chip
        type="rectangular"
        className={classes.rating}
        closeClick={() => this.handleChange({id: 'rating', value: false})}
      >
        <ReactStars
          count={5}
          size={12}
          half={false}
          value={value}
          color1={'#ACB3BE'}
          color2={'#FFA701'}
          onChange={(value) => this.handleChange({id: 'rating', value})}
        />
      </Chip>);
  }

  render() {
    const {focus} = this.state;
    const {
      id,
      classes,
      className,
      visibility,
      placeholder,
      value,
      type,
      sendButtonLabel,
      cancelButtonLabel,
      autoFocus,
      error,
      options,
      onCancel,
      maxFileSize,
      maxFileSizeErrorText,
      onKeyPress
    } = this.props;

    const formClasses = cn(
      className,
      classes.sendForm,
      classes[type],
      {focus},
      {error: !!error},
      {hidden: visibility === 'hidden'},
      {disabled: visibility === 'disabled'},
    );

    return (
      <div
        id={id}
        className={formClasses}
        ref={(el) => (this.sendForm = el)}
      >
        <ForwardTextField
          ref={this.refEdit}
          id="message"
          className={classes.input}
          autoFocus={autoFocus}
          visibility={visibility}
          value={value.message}
          placeholder={placeholder}
          onChange={(e) => this.handleChange(e, 'message')}
          onFocus={this.handleFocus}
          onKeyDown={this.handleKeyDown}
          onKeyPress={onKeyPress}
          onKeyUp={this.handleKeyUp}
          onBlur={this._saveCursorPosition}
          multiline={true}
        />
        <div className={classes.artifacts}>
          {value.sign ? this.renderSign() : null}
          {value.rating && value.rating !== 0 ? this.renderRate(value.rating) : null}
        </div>
        <div className={classes.controls} ref={(el) => (this.controls = el)}>
          <div className={classes.controlsIcons}>
            {options.users ?
              <Icon
                className={classes.controlsIconsItem}
                type="dog"
                size="medium"
                onClick={this.showUsers}
              /> : null
            }
            {options.smiles ?
              <Emoji
                className={classes.controlsIconsItem}
                visibility={visibility}
                size="medium"
                onChange={
                  ({value}) => this.selectEmoji(value)
                }
              /> : null
            }
            {options.files ?
              <Upload
                id="files"
                visibility={visibility}
                className={classes.controlsIconsItem}
                multiple={options.files.multiple}
                preview={options.files.preview}
                accept={options.files.accept}
                value={value.files}
                portal={this.portalEl}
                maxFileSize={maxFileSize}
                maxFileSizeErrorText={maxFileSizeErrorText}
                onChange={(e) => this.handleChange(e, 'files')}
              >
                <Icon
                  type={'attach'}
                  size="medium"
                />
              </Upload> : null
            }
            {options.sign ?
              <Icon
                className={classes.controlsIconsItem}
                type={'sign'}
                size="medium"
                onClick={() => this.handleChange({id: 'sign', value: true})}
              /> : null}
            {options.rating ?
              <Icon
                className={classes.controlsIconsItem}
                type={'star_full'}
                size="medium"
                onClick={() => this.handleChange({id: 'rating', value: 1})}
              /> : null}
          </div>
          <div className={classes.controlsBtn}>
            {cancelButtonLabel ?
              <Button
                size="small"
                type="text"
                label={cancelButtonLabel}
                onClick={() => onCancel({id, value, error})}
              /> : null
            }
            {sendButtonLabel ?
              <Button
                size="small"
                label={sendButtonLabel}
                onClick={this.handleSubmit}
                visibility={!error &&
                (value.message || (value.files && value.files.length) ||
                  (value.users && value.users.length) || value.sign || value.rating)
                  ?
                  'visible' :
                  'disabled'}
              /> : null}
          </div>
        </div>
        {this.renderUsers()}
      </div>
    );
  }
}

SendForm.defaultProps = {
  visibility: 'visible',
  error: false,
  value: {
    message: '',
    files: [],
    users: [],
    sign: false,
    rating: 0
  },
  sendButtonLabel: 'Send',
  type: 'chat',
  options: {
    smiles: {},
    files: {multiple: true, preview: true},
    users: [],
    sign: false,
    rating: false
  },
  onSubmit: () => {
  },
  onCancel: () => {
  },
  onChange: () => {
  },
  onKeyDown: () => {
  },
  onKeyUp: () => {
  },
  onKeyPress: () => {
  }
};

SendForm.propTypes = {
  classes: PropTypes.object,
  /** SendForm's visibility */
  visibility: PropTypes.oneOf(['visible', 'disabled', 'hidden']).isRequired,
  /** Does SendForm has an error */
  error: PropTypes.bool.isRequired,
  /** SendForm's id */
  id: PropTypes.string,
  /** SendForm's type */
  type: PropTypes.oneOf(['chat', 'comment']).isRequired,
  /** SendForm's options */
  options: PropTypes.object,
  /** additional external class name */
  className: PropTypes.string,
  /** form placeholder */
  placeholder: PropTypes.string,
  /** send button label */
  sendButtonLabel: PropTypes.string,
  /** cancel button label */
  cancelButtonLabel: PropTypes.string,
  /** forms value */
  value: PropTypes.object,
  /** form autoFocus */
  autoFocus: PropTypes.bool,
  /** onSubmit callback */
  onSubmit: PropTypes.func,
  /** onCancel callback */
  onCancel: PropTypes.func,
  /** onChange callback */
  onChange: PropTypes.func,
  /** onKeyDown callback */
  onKeyDown: PropTypes.func,
  /** onKeyUp callback */
  onKeyUp: PropTypes.func,
  /** onKeyPress callback */
  onKeyPress: PropTypes.func,
  /** Use that property to pass a ref callback to the native input component. */
  forwardRef: PropTypes.object,
  /** Max file size's id */
  maxFileSize: PropTypes.number,
  /** Max File size error text */
  maxFileSizeErrorText: PropTypes.string,
};

export default SendForm;
