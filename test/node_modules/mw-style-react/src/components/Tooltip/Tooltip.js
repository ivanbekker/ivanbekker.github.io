import PropTypes from 'prop-types';
import React, {Fragment, PureComponent} from 'react';
import ReactDOM from 'react-dom';
import injectSheet from 'react-jss';
import cn from 'clsx';
import Label from '../Label/Label.js';
import styles from './Tooltip.style';


@injectSheet(styles)
class Tooltip extends PureComponent {
  constructor(props, context) {
    super(props, context);
    this.state = {
      position: {left: 0, top: 0},
      side: null,
      arrowSize: 6,
      tooltip: false,
      parentNodePosition: {left: 0, top: 0, width: 0, height: 0}
    };
    this.showTooltip = ::this.showTooltip;
    this.hideTooltip = ::this.hideTooltip;
  }

  componentWillMount() {
    this._isMounted = true;
  }

  componentWillUnmount() {
    this._isMounted = false;
  }

  showTooltip(e) {
    const {value} = this.props;
    if (!value) return;
    this.debaunce = true;
    const el = e.target;
    this.setState({
      tooltip: true
    });

    setTimeout(() => {
      if (!this.debaunce || !this._isMounted) return;
      this.debaunce = false;
      this.setTooltipPosition(el);
    }, 200);
  }

  hideTooltip() {
    this.debaunce = false;
    this.setState({
      tooltip: false
    });
  }

  // set tooltip position
  setTooltipPosition(parEl) {
    const pointPar = this.getParentPoints(parEl);
    const posTooltip = this.getPosTooltip(pointPar);
    const side = this.getSide(posTooltip);

    this.setState({
      position: {
        left: `${posTooltip[side].left}px`,
        top: `${posTooltip[side].top}px`
      },
      side
    });
  }

  // calculate parent's node center points for each side
  getParentPoints(target) {
    const {left, top, width, height} = target.getBoundingClientRect();
    const {parentNodePosition} = this.state;
    return {
      top: {
        x: left + (width / 2) - parentNodePosition.left,
        y: top + parentNodePosition.top
      },
      left: {
        x: left - parentNodePosition.left,
        y: top - parentNodePosition.top + (height / 2)
      },
      right: {
        x: left - parentNodePosition.left + width,
        y: top - parentNodePosition.top + (height / 2)
      },
      bottom: {
        x: left - parentNodePosition.left + (width / 2),
        y: top - parentNodePosition.top + height
      }
    };
  }

  // calculate tooltip position relative to parent node
  getPosTooltip(pointPar) {
    const arrow = this.state.arrowSize;
    return {
      bottom: {
        left: pointPar.bottom.x - (this.el.offsetWidth / 2),
        top: pointPar.bottom.y + arrow
      },
      top: {
        left: pointPar.top.x - (this.el.offsetWidth / 2),
        top: pointPar.top.y - arrow - this.el.offsetHeight
      },
      left: {
        left: pointPar.left.x - arrow - this.el.offsetWidth,
        top: pointPar.left.y - (this.el.offsetHeight / 2)
      },
      right: {
        left: pointPar.right.x + arrow,
        top: pointPar.right.y - (this.el.offsetHeight / 2)
      }
    };
  }

  // calculate best side for display tooltip
  getSide(posTooltip) {
    const {parentNodePosition} = this.state;
    const heightTooltip = this.el.offsetHeight;
    const widthTooltip = this.el.offsetWidth;
    const heightWindow = window.innerHeight;
    const widthWindow = window.innerWidth;
    const arrow = this.state.arrowSize;

    if (
      posTooltip.bottom.left + parentNodePosition.left > 0 &&
      posTooltip.bottom.left + parentNodePosition.left + widthTooltip < widthWindow &&
      posTooltip.bottom.top + parentNodePosition.top + heightTooltip + arrow < heightWindow
    ) {
      return 'bottom';
    } else if (
      posTooltip.right.left + parentNodePosition.left + widthTooltip + arrow < widthWindow
    ) {
      return 'right';
    } else if (
      posTooltip.left.left - arrow + parentNodePosition.left > 0
    ) {
      return 'left';
    }

    return 'top';
  }

  renderTip() {
    const {
      classes,
      className,
      value
    } = this.props;

    const {
      side,
      position,
      tooltip
    } = this.state;
    const classNames = cn(
      className,
      classes.tooltip,
      classes[`${side}Side`],
      {[classes.active]: tooltip && position.top !== '0'}
    );

    // убирать со страници после окончания анимации закрытия
    if (position.left !== '-100000px' && position.top !== '0' && !tooltip) {
      setTimeout(() => {
        if (!this._isMounted) return;
        this.setState({
          position: {
            left: '-100000px',
            top: '0'
          },
        });
      }, 200);
    }

    if (!tooltip) return null;

    return (
      <div
        ref={el => (this.el = el)}
        className={classNames}
        style={{left: position.left, top: position.top}}
        onClick={this.onClick}
      >
        <Label
          value={value}
          className={cn(classes.text)}
        />
        <div
          className={cn(classes.arrow, classes[side])}
        />
      </div>
    );
  }

  render() {
    const {children} = this.props;
    return (
      <Fragment>
        {React.Children.map(children, (child) => (
          React.cloneElement(child, {
            onMouseEnter: this.showTooltip,
            onMouseLeave: this.hideTooltip
          })
        ))}
        {ReactDOM.createPortal(this.renderTip(), document.body)}
      </Fragment>
    );
  }
}

Tooltip.propTypes = {
  classes: PropTypes.object,
  /** additional external class name */
  className: PropTypes.string,
  /** children */
  children: PropTypes.node.isRequired,
  /** Tooltip's value */
  value: PropTypes.string
};

export default Tooltip;
