'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _dec, _class;

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _reactJss = require('react-jss');

var _reactJss2 = _interopRequireDefault(_reactJss);

var _clsx = require('clsx');

var _clsx2 = _interopRequireDefault(_clsx);

var _Label = require('../Label/Label.js');

var _Label2 = _interopRequireDefault(_Label);

var _Tooltip = require('./Tooltip.style');

var _Tooltip2 = _interopRequireDefault(_Tooltip);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Tooltip = (_dec = (0, _reactJss2.default)(_Tooltip2.default), _dec(_class = function (_PureComponent) {
  (0, _inherits3.default)(Tooltip, _PureComponent);

  function Tooltip(props, context) {
    (0, _classCallCheck3.default)(this, Tooltip);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Tooltip.__proto__ || (0, _getPrototypeOf2.default)(Tooltip)).call(this, props, context));

    _this.state = {
      position: { left: 0, top: 0 },
      side: null,
      arrowSize: 6,
      tooltip: false,
      parentNodePosition: { left: 0, top: 0, width: 0, height: 0 }
    };
    _this.showTooltip = _this.showTooltip.bind(_this);
    _this.hideTooltip = _this.hideTooltip.bind(_this);
    return _this;
  }

  (0, _createClass3.default)(Tooltip, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      this._isMounted = true;
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this._isMounted = false;
    }
  }, {
    key: 'showTooltip',
    value: function showTooltip(e) {
      var _this2 = this;

      var value = this.props.value;

      if (!value) return;
      this.debaunce = true;
      var el = e.target;
      this.setState({
        tooltip: true
      });

      setTimeout(function () {
        if (!_this2.debaunce || !_this2._isMounted) return;
        _this2.debaunce = false;
        _this2.setTooltipPosition(el);
      }, 200);
    }
  }, {
    key: 'hideTooltip',
    value: function hideTooltip() {
      this.debaunce = false;
      this.setState({
        tooltip: false
      });
    }

    // set tooltip position

  }, {
    key: 'setTooltipPosition',
    value: function setTooltipPosition(parEl) {
      var pointPar = this.getParentPoints(parEl);
      var posTooltip = this.getPosTooltip(pointPar);
      var side = this.getSide(posTooltip);

      this.setState({
        position: {
          left: posTooltip[side].left + 'px',
          top: posTooltip[side].top + 'px'
        },
        side: side
      });
    }

    // calculate parent's node center points for each side

  }, {
    key: 'getParentPoints',
    value: function getParentPoints(target) {
      var _target$getBoundingCl = target.getBoundingClientRect(),
          left = _target$getBoundingCl.left,
          top = _target$getBoundingCl.top,
          width = _target$getBoundingCl.width,
          height = _target$getBoundingCl.height;

      var parentNodePosition = this.state.parentNodePosition;

      return {
        top: {
          x: left + width / 2 - parentNodePosition.left,
          y: top + parentNodePosition.top
        },
        left: {
          x: left - parentNodePosition.left,
          y: top - parentNodePosition.top + height / 2
        },
        right: {
          x: left - parentNodePosition.left + width,
          y: top - parentNodePosition.top + height / 2
        },
        bottom: {
          x: left - parentNodePosition.left + width / 2,
          y: top - parentNodePosition.top + height
        }
      };
    }

    // calculate tooltip position relative to parent node

  }, {
    key: 'getPosTooltip',
    value: function getPosTooltip(pointPar) {
      var arrow = this.state.arrowSize;
      return {
        bottom: {
          left: pointPar.bottom.x - this.el.offsetWidth / 2,
          top: pointPar.bottom.y + arrow
        },
        top: {
          left: pointPar.top.x - this.el.offsetWidth / 2,
          top: pointPar.top.y - arrow - this.el.offsetHeight
        },
        left: {
          left: pointPar.left.x - arrow - this.el.offsetWidth,
          top: pointPar.left.y - this.el.offsetHeight / 2
        },
        right: {
          left: pointPar.right.x + arrow,
          top: pointPar.right.y - this.el.offsetHeight / 2
        }
      };
    }

    // calculate best side for display tooltip

  }, {
    key: 'getSide',
    value: function getSide(posTooltip) {
      var parentNodePosition = this.state.parentNodePosition;

      var heightTooltip = this.el.offsetHeight;
      var widthTooltip = this.el.offsetWidth;
      var heightWindow = window.innerHeight;
      var widthWindow = window.innerWidth;
      var arrow = this.state.arrowSize;

      if (posTooltip.bottom.left + parentNodePosition.left > 0 && posTooltip.bottom.left + parentNodePosition.left + widthTooltip < widthWindow && posTooltip.bottom.top + parentNodePosition.top + heightTooltip + arrow < heightWindow) {
        return 'bottom';
      } else if (posTooltip.right.left + parentNodePosition.left + widthTooltip + arrow < widthWindow) {
        return 'right';
      } else if (posTooltip.left.left - arrow + parentNodePosition.left > 0) {
        return 'left';
      }

      return 'top';
    }
  }, {
    key: 'renderTip',
    value: function renderTip() {
      var _this3 = this;

      var _props = this.props,
          classes = _props.classes,
          className = _props.className,
          value = _props.value;
      var _state = this.state,
          side = _state.side,
          position = _state.position,
          tooltip = _state.tooltip;

      var classNames = (0, _clsx2.default)(className, classes.tooltip, classes[side + 'Side'], (0, _defineProperty3.default)({}, classes.active, tooltip && position.top !== '0'));

      // убирать со страници после окончания анимации закрытия
      if (position.left !== '-100000px' && position.top !== '0' && !tooltip) {
        setTimeout(function () {
          if (!_this3._isMounted) return;
          _this3.setState({
            position: {
              left: '-100000px',
              top: '0'
            }
          });
        }, 200);
      }

      if (!tooltip) return null;

      return _react2.default.createElement(
        'div',
        {
          ref: function ref(el) {
            return _this3.el = el;
          },
          className: classNames,
          style: { left: position.left, top: position.top },
          onClick: this.onClick
        },
        _react2.default.createElement(_Label2.default, {
          value: value,
          className: (0, _clsx2.default)(classes.text)
        }),
        _react2.default.createElement('div', {
          className: (0, _clsx2.default)(classes.arrow, classes[side])
        })
      );
    }
  }, {
    key: 'render',
    value: function render() {
      var _this4 = this;

      var children = this.props.children;

      return _react2.default.createElement(
        _react.Fragment,
        null,
        _react2.default.Children.map(children, function (child) {
          return _react2.default.cloneElement(child, {
            onMouseEnter: _this4.showTooltip,
            onMouseLeave: _this4.hideTooltip
          });
        }),
        _reactDom2.default.createPortal(this.renderTip(), document.body)
      );
    }
  }]);
  return Tooltip;
}(_react.PureComponent)) || _class);


Tooltip.propTypes = {
  classes: _propTypes2.default.object,
  /** additional external class name */
  className: _propTypes2.default.string,
  /** children */
  children: _propTypes2.default.node.isRequired,
  /** Tooltip's value */
  value: _propTypes2.default.string
};

exports.default = Tooltip;