/**
 * Контейнер с выбором месяца и года
 * */
import PropTypes from 'prop-types';
import React, {PureComponent} from 'react';
import injectSheet from 'react-jss';
import cn from 'clsx';
import styles from './PeriodChange.style';
import Icon from '../../Icon';
import Label from '../../Label';
import DateUtils from '../../utils/dateUtils';

@injectSheet(styles)
class PeriodChange extends PureComponent {
  // Проверка можно ли листать месяц/год вперед
  canNext(type) {
    const {viewDate, maxValue} = this.props;
    if (!maxValue) return true;
    if (type === 'month') {
      return (
        maxValue.getFullYear() > viewDate.getFullYear() ||
        (maxValue.getFullYear() >= viewDate.getFullYear() &&
          maxValue.getMonth() > viewDate.getMonth())
      );
    }
    return maxValue.getFullYear() > viewDate.getFullYear();
  }

  // Проверка можно ли листать месяц/год назад
  canPrev(type) {
    const {viewDate, minValue} = this.props;
    if (!minValue) return true;
    if (type === 'month') {
      return (
        minValue.getFullYear() < viewDate.getFullYear() ||
        (minValue.getFullYear() === viewDate.getFullYear() &&
          minValue.getMonth() <= viewDate.getMonth() - 1)
      );
    }
    return minValue.getFullYear() < viewDate.getFullYear();
  }

  // Переключение месяца
  handleChangeMonth(direction) {
    const {viewDate, onChange} = this.props;
    const changedDate = new Date(viewDate);
    if (direction === 'prev' && this.canPrev('month')) {
      changedDate.setMonth(viewDate.getMonth() - 1, 1);
    } else if (direction === 'next' && this.canNext('month')) {
      changedDate.setMonth(viewDate.getMonth() + 1, 1);
    }
    onChange(changedDate);
  }

  // Переключение года
  handleChangeYear(direction) {
    const {maxValue, minValue, viewDate, onChange} = this.props;
    const changedDate = new Date(viewDate);
    if (direction === 'prev' && this.canPrev('year')) {
      changedDate.setFullYear(viewDate.getFullYear() - 1);
    } else if (direction === 'next' && this.canNext('year')) {
      changedDate.setFullYear(viewDate.getFullYear() + 1);
    }
    // Корректировка максимального и минимального месяца
    if (!this.canNext('month') && changedDate.getMonth() !== maxValue.getMonth()) {
      changedDate.setMonth(maxValue.getMonth());
    } else if (!this.canPrev('month') && changedDate.getMonth() !== minValue.getMonth()) {
      changedDate.setMonth(minValue.getMonth());
    }
    onChange(changedDate);
  }

  render() {
    const {classes, className, size, viewDate} = this.props;
    const month = viewDate.getMonth();
    const year = viewDate.getFullYear();
    return (
      <div className={cn(className, classes[size], classes.period)}>
        <Icon
          className={cn(classes.periodItem, classes.periodIcon, classes.prevYearIcon)}
          type="arrows"
          onClick={() => this.handleChangeYear('prev')}
          visibility={this.canPrev('year') ? 'visible' : 'disabled'}
          size="small"
          color="currentColor"
        />
        <Icon
          className={cn(classes.periodItem, classes.periodIcon, classes.prevMonthIcon)}
          type="arrow"
          onClick={() => this.handleChangeMonth('prev')}
          visibility={this.canPrev('month') ? 'visible' : 'disabled'}
          size="small"
          color="currentColor"
        />
        <Label
          className={cn(classes.periodItem, classes.monthYear)}
          value={`${DateUtils.getMonth([month])}, ${year}`}
          fontSize={size}
          fontWeight="semibold"
        />
        <Icon
          className={cn(classes.periodItem, classes.periodIcon, classes.nextMonthIcon)}
          type="arrow"
          onClick={() => this.handleChangeMonth('next')}
          visibility={this.canNext('month') ? 'visible' : 'disabled'}
          size="small"
          color="currentColor"
        />
        <Icon
          className={cn(classes.periodItem, classes.periodIcon, classes.nextYearIcon)}
          type="arrows"
          onClick={() => this.handleChangeYear('next')}
          visibility={this.canNext('year') ? 'visible' : 'disabled'}
          size="small"
          color="currentColor"
        />
      </div>
    );
  }
}

PeriodChange.propTypes = {
  classes: PropTypes.object,
  /** additional external class name */
  className: PropTypes.string,
  /** PeriodChange size */
  size: PropTypes.oneOf(['small', 'medium']).isRequired,
  /** PeriodChange max date */
  maxValue: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.string]).isRequired,
  /** PeriodChange min date */
  minValue: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.string]).isRequired,
  /** PeriodChange view date */
  viewDate: PropTypes.instanceOf(Date).isRequired,
  /** PeriodChange callback */
  onChange: PropTypes.func.isRequired,
};

export default PeriodChange;
