import PropTypes from 'prop-types';
import React, {PureComponent, Fragment} from 'react';
import injectSheet from 'react-jss';
import cn from 'clsx';
import enhanceWithClickOutside from 'react-click-outside';
import Label from '../Label';
import Divider from '../Divider';
import TextField from '../TextField';
import Select from '../Select';
import Button from '../Button';
import MenuItem from '../Menu/MenuItem';
import TIME_ZONE from './timezone.js';
import REMIND_LIST from './remindList.js';
import DateUtils from '../utils/dateUtils';
import styles from './Calendar.style';
import PeriodChange from './PeriodChange';
import WeekDays from './WeekDays';
import Days from './Days';

const DEFAULT_TIMEZONE_OFFSET = new Date().getTimezoneOffset();

@injectSheet(styles)
@enhanceWithClickOutside
class Calendar extends PureComponent {
  constructor(props) {
    super(props);
    const {unix, timeZoneOffset, remindTime} = this.props.value;
    const date = unix ? new Date(unix * 1000) : this.setBaseDateAndHours();
    const {hours, minutes} = this.correctTime(date.getHours(), date.getMinutes());
    this.state = {
      viewDate: date,
      changedTime: {
        hours,
        minutes,
      },
      selectedDate: {
        selectedDay: date.getDate(),
        selectedMonth: date.getMonth() + 1,
        selectedYear: date.getFullYear(),
      },
      timeZoneOffset: timeZoneOffset || DEFAULT_TIMEZONE_OFFSET,
      maxValue: props.maxValue && new Date(props.maxValue * 1000),
      minValue: props.minValue && new Date(props.minValue * 1000),
      remindValue: REMIND_LIST[0].value,
      remindTime: remindTime || null,
    };
    this.handleChangeTimeZoneOffset = ::this.handleChangeTimeZoneOffset;
    this.handleChangeTime = ::this.handleChangeTime;
    this.handleBlurTime = ::this.handleBlurTime;
    this.handleFocusTime = ::this.handleFocusTime;
    this.handleChangeRemind = ::this.handleChangeRemind;
    this.handlePeriodChange = ::this.handlePeriodChange;
    this.handleDaysChange = ::this.handleDaysChange;
    this.handleClickConfirmButton = ::this.handleClickConfirmButton;
  }

  componentWillMount() {
    this.setState({remindValue: this.getRemindValue()});
  }

  componentWillReceiveProps(nextProps, props) {
    const {unix, timeZoneOffset} = nextProps.value;
    if (unix !== props.unix || timeZoneOffset !== props.timeZoneOffset) {
      const date = new Date(unix * 1000);
      const {hours, minutes} = this.correctTime(date.getHours(), date.getMinutes());
      this.setState({
        viewDate: date,
        changedTime: {
          hours,
          minutes,
        },
        timeZoneOffset: timeZoneOffset || DEFAULT_TIMEZONE_OFFSET,
      });
    }
  }

  // Установить время по умолчанию в 12:00
  setBaseDateAndHours() {
    const date = new Date();
    date.setHours(12, 0, 0, 0);
    return new Date(date);
  }

  // Handler for click outside of component
  handleClickOutside(e) {
    if (this.timeZoneOffsetRef && this.timeZoneOffsetRef.contains(e.target)) return;
    if (this.remindRef && this.remindRef.contains(e.target)) return;
    const {onClose} = this.props;
    onClose();
  }

  // Изменить минуты/секунды
  handleChangeTime(data) {
    this.setState({
      changedTime: {
        ...this.state.changedTime,
        [data.id]: data.value,
      },
    });
  }

  // Сохранить минуты/секунды
  handleBlurTime() {
    const {viewDate, changedTime} = this.state;
    const changedDate = new Date(viewDate);
    const {hours, minutes} = this.correctTime(changedTime.hours, changedTime.minutes);
    changedDate.setHours(hours);
    changedDate.setMinutes(minutes);
    this.setState({
      viewDate: changedDate,
      changedTime: {
        hours,
        minutes,
      },
    });
  }

  // Обработчик смены года/месяца
  handlePeriodChange(value) {
    this.setState({
      viewDate: value,
    });
  }

  // Обработчик выбора дня
  handleDaysChange(value) {
    const {viewDate} = this.state;
    const changedDate = new Date(viewDate);
    changedDate.setMonth(value.selectedMonth - 1, 1);
    changedDate.setFullYear(value.selectedYear);
    // console.log('changedDate ', changedDate);
    this.setState({
      selectedDate: value,
      viewDate: changedDate,
    });
  }

  // Очистить поле ввода минут/секунд
  handleFocusTime(e) {
    const {id} = this[`${e}Ref`].props;
    this.setState({
      changedTime: {
        ...this.state.changedTime,
        [id]: '',
      },
    });
  }

  // Изменить таймзону
  handleChangeTimeZoneOffset(data) {
    this.setState({
      timeZoneOffset: +data.value,
    });
  }

  // Получить значение remindValue
  getRemindValue() {
    const {unix} = this.props.value;
    const {remindTime} = this.state;
    let remindValue = 0;
    if (remindTime && unix) {
      const selectedUnix = this.getSelectedUnixtime();
      REMIND_LIST.forEach((item, index) => {
        const {value} = item;
        if (selectedUnix - remindTime === value) {
          remindValue = index.toString();
        }
      });
    }
    return remindValue.toString();
  }

  // Получить время напоминания
  getRemindTime(remindValue) {
    if (+remindValue) {
      return this.getSelectedUnixtime() - REMIND_LIST[remindValue].value;
    }
    return null;
  }

  // Изменить время напоминания
  handleChangeRemind({value}) {
    this.setState({
      remindValue: value,
      remindTime: this.getRemindTime(value),
    });
  }

  // Корректировка времени для правильного сохранения и отображения
  correctTime(h, m) {
    let hours = +h;
    let minutes = +m;
    if (isNaN(hours)) {
      hours = 0;
    } else if (h > 23) {
      hours = 23;
    }
    if (isNaN(minutes)) {
      minutes = 0;
    } else if (m > 59) {
      minutes = 59;
    }
    return {
      hours: DateUtils.addZero(hours),
      minutes: DateUtils.addZero(minutes),
    };
  }

  // Получить текущую выбранную дату в unixtime
  getSelectedUnixtime() {
    const {viewDate, selectedDate} = this.state;
    const {selectedDay, selectedMonth} = selectedDate;
    const callbackDate = new Date(viewDate);
    callbackDate.setDate(selectedDay);
    callbackDate.setMonth(selectedMonth - 1);
    return DateUtils.dateToUnixtime(callbackDate);
  }

  // Применить выбранную дату, таймзону, время напоминания
  handleClickConfirmButton(e) {
    e.stopPropagation();
    const {id, onChange, onClose} = this.props;
    const {timeZoneOffset, remindValue} = this.state;
    const value = {
      unix: this.getSelectedUnixtime(),
      timeZoneOffset,
      remindTime: this.getRemindTime(remindValue),
    };
    // выполнение колбэков
    onChange({id, value, error: false});
    onClose();
  }

  // Контейнер с выбором и корректирой времени
  renderTimeContainer() {
    const {classes, time, timeZone, remind, size} = this.props;
    const {changedTime, timeZoneOffset, remindValue} = this.state;
    const {hours, minutes} = changedTime;
    return time || timeZone || remind ? (
      <Fragment>
        <Divider/>
        <div className={cn(classes.footer)}>
          {timeZone ? (
            <div className={cn(classes.footerRow)}>
              <Label className={cn(classes.footerLabel)} fontSize={size} value="Timezone"/>
              <div
                ref={el => {
                  this.timeZoneOffsetRef = el;
                }}
                className={cn(classes.selectContainer)}
              >
                <Select
                  className={cn(classes.select)}
                  value={timeZoneOffset.toString()}
                  onChange={this.handleChangeTimeZoneOffset}
                >
                  {TIME_ZONE.map((t, index) => (
                    <MenuItem
                      key={index}
                      label={t.label}
                      value={t.value.toString()}
                      activeItem={timeZoneOffset.toString()}
                    />
                  ))}
                </Select>
              </div>
            </div>
          ) : null}
          {time ? (
            <div className={cn(classes.footerRow)}>
              <Label className={cn(classes.footerLabel)} fontSize={size} value="End time"/>
              <div className={cn(classes.timeContainer)}>
                <TextField
                  className={cn(classes.time)}
                  id="hours"
                  type="int"
                  size="small"
                  value={hours.toString()}
                  length={2}
                  autoFocus={false}
                  onChange={this.handleChangeTime}
                  onBlur={this.handleBlurTime}
                  onFocus={this.handleFocusTime}
                  ref={el => {
                    this.hoursRef = el;
                  }}
                />
                <Label className={cn(classes.timeSeparator)} value=":"/>
                <TextField
                  className={cn(classes.time)}
                  id="minutes"
                  type="int"
                  size="small"
                  value={minutes.toString()}
                  length={2}
                  autoFocus={false}
                  onChange={this.handleChangeTime}
                  onBlur={this.handleBlurTime}
                  onFocus={this.handleFocusTime}
                  ref={el => {
                    this.minutesRef = el;
                  }}
                />
              </div>
            </div>
          ) : null}
          {remind ? (
            <div className={cn(classes.footerRow)}>
              <Label className={cn(classes.footerLabel)} fontSize={size} value="Remind"/>
              <div
                ref={el => {
                  this.remindRef = el;
                }}
                className={cn(classes.selectContainer)}
              >
                <Select
                  className={cn(classes.select)}
                  value={remindValue}
                  onChange={this.handleChangeRemind}
                >
                  {REMIND_LIST.map((item, index) => (
                    <MenuItem
                      key={index}
                      label={item.label}
                      value={index.toString()}
                      activeItem={remindValue}
                    />
                  ))}
                </Select>
              </div>
            </div>
          ) : null}
        </div>
      </Fragment>
    ) : null;
  }

  render() {
    const {classes, className, id, visibility, size, time, isoDays} = this.props;
    const {viewDate, maxValue, minValue, selectedDate} = this.state;
    return (
      <div id={id} className={cn(className, classes.calendar, classes[size], classes[visibility])}>
        <PeriodChange
          size={size}
          viewDate={viewDate}
          onChange={this.handlePeriodChange}
          maxValue={maxValue}
          minValue={minValue}
        />
        <WeekDays size={size} isoDays={isoDays}/>
        <Days
          size={size}
          minValue={minValue}
          maxValue={maxValue}
          isoDays={isoDays}
          onChange={this.handleDaysChange}
          selectedDate={selectedDate}
          viewDate={viewDate}
        />
        {this.renderTimeContainer()}
        <Button
          className={cn(classes.confirmButton)}
          label={time ? 'Choose the date and time' : 'Choose the date'}
          onClick={this.handleClickConfirmButton}
          size={size}
        />
      </div>
    );
  }
}

Calendar.defaultProps = {
  size: 'medium',
  visibility: 'visible',
  isoDays: true,
  value: {},
  maxValue: '',
  minValue: '',
  onChange: () => {
  },
  onClose: () => {
  },
};

Calendar.propTypes = {
  classes: PropTypes.object,
  /** additional external class name */
  className: PropTypes.string,
  /** Calendar's visibility */
  visibility: PropTypes.oneOf(['visible', 'hidden']),
  /** Calendar's size */
  size: PropTypes.oneOf(['small', 'medium']),
  /** Calendar's id */
  id: PropTypes.string,
  /** Calendar's first day of the week is Monday by ISO-8601 */
  isoDays: PropTypes.bool,
  /** Calendar's value */
  value: PropTypes.shape({
    unix: PropTypes.number,
    timeZoneOffset: PropTypes.number,
    remindTime: PropTypes.number,
  }),
  /** Calendar's max date */
  maxValue: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  /** Calendar's min date */
  minValue: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  /** Calendar's time */
  time: PropTypes.bool,
  /** Calendar's time zone */
  timeZone: PropTypes.bool,
  /** Calendar's time zone */
  remind: PropTypes.bool,
  /** Calendar's callback */
  onChange: PropTypes.func,
  /** Calendar's callback */
  onClose: PropTypes.func,
};

export default Calendar;
