import React from 'react';
import PropTypes from 'prop-types';

export default function withForm(formProps, Form) {
  /**
   * Default handlers
   */
  const defFormProps = {
    handleSubmit: () => {
    },
    handleOnChange: field => field,
    setValues: values => values,
    mapPropsToValues: () => ({}),
    defaultErrorMsg: {},
    validate: () => ({}),
    yup: null,
  };

  /**
   * Handlers merge
   */
  const customFormProps = Object.assign({}, defFormProps, formProps);

  /**
   * HOC for handle form
   */
  class WithForm extends React.Component {
    constructor(props) {
      super(props);
      this.state = {
        values: customFormProps.mapPropsToValues(props),
        errors: {},
        isSubmit: false,
      };
      this.setSubmitting = ::this.setSubmitting;
      this.setErrors = ::this.setErrors;
      this.setValues = ::this.setValues;
      this.handleSubmit = ::this.handleSubmit;
      this.handleOnChange = ::this.handleOnChange;
      this.removeError = ::this.removeError;
      this.handleKeyPress = ::this.handleKeyPress;
    }

    componentWillReceiveProps(nextProps) {
      const prevData = JSON.stringify(customFormProps.mapPropsToValues(this.props));
      const nextData = JSON.stringify(customFormProps.mapPropsToValues(nextProps));
      if (prevData !== nextData) {
        this.setState({
          values: customFormProps.mapPropsToValues(nextProps),
        });
      }
    }

    // Handler on change field
    handleOnChange(field) {
      const {id, value, error} = customFormProps.handleOnChange(field, this.props);
      const objVal = {[id]: value};
      const values = {...this.state.values, ...objVal};
      this.setValues(values);
      if (error) {
        const errorMsg = this.getDefaultErrorMsg(id);
        this.setErrors({[id]: errorMsg});
      } else {
        this.removeError(id);
      }
    }

    // Handler on submit form
    async handleSubmit(arg, options = {skipValidation: false}) {
      const {dispatch} = this.props;
      const {values, errors} = this.state;
      if (!options.skipValidation) {
        const validationErrors = await this.runValidation(values);
        const allErrors = Object.assign({}, errors, validationErrors);
        this.setErrors(allErrors);

        const findErrors = Object.keys(allErrors).filter(key => !!allErrors[key]);
        if (findErrors.length > 0) return;
      }

      this.setSubmitting(true);
      customFormProps.handleSubmit(
        values,
        dispatch,
        {
          setSubmitting: this.setSubmitting,
          setErrors: this.setErrors,
          setValues: this.setValues,
        },
        this.props,
        arg,
      );
    }

    // Handler on field key press
    handleKeyPress(e) {
      if (customFormProps.handleKeyPress) {
        customFormProps.handleKeyPress(e, this.props, {
          setSubmitting: this.setSubmitting,
          setErrors: this.setErrors,
          setValues: this.setValues,
          handleSubmit: this.handleSubmit,
          handleOnChange: this.handleOnChange,
        });
      } else if (e && e.key === 'Enter') {
        this.handleSubmit();
      }
    }

    // Set form status
    setSubmitting(isSubmit) {
      this.setState({isSubmit});
    }

    // Set error message from defaultErrorMsg
    getDefaultErrorMsg(id) {
      const defaultErrorMsg = customFormProps.defaultErrorMsg;
      return defaultErrorMsg[id] || 'Incorrect data';
    }

    // Set fileds errors
    setErrors(errors) {
      this.setSubmitting(false);
      this.setState({
        errors: {...this.state.errors, ...errors},
      });
    }

    // Remove error from fields
    removeError(id) {
      const errors = Object.assign({}, this.state.errors);
      delete errors[id];
      this.setState({errors});
    }

    // Set fields values
    setValues(values) {
      values = customFormProps.setValues(values);
      this.setState({
        values: {...this.state.values, ...values},
      });
    }

    // Form validation
    async runValidation(values) {
      const customValidator = customFormProps.validate(values);
      if (customFormProps.yup) {
        try {
          const yup =
            typeof customFormProps.yup === 'function'
              ? customFormProps.yup(this.props)
              : customFormProps.yup;
          await yup.validate(values, {abortEarly: false});
        } catch (e) {
          const yupError = this.yupToFormErrors(e);
          return Object.assign({}, yupError, customValidator);
        }
      }
      return customValidator;
    }

    // Convert errors from YUP to form format
    yupToFormErrors(yupError) {
      const errors = {};
      for (const err of yupError.inner) {
        if (err.path) {
          errors[err.path] = err.message;
        }
      }
      return errors;
    }

    render() {
      return (
        <Form
          {...this.props}
          {...this.state}
          setValues={this.setValues}
          setErrors={this.setErrors}
          removeError={this.removeError}
          handleOnChange={this.handleOnChange}
          handleSubmit={this.handleSubmit}
          handleKeyPress={this.handleKeyPress}
        />
      );
    }
  }

  WithForm.propTypes = {
    dispatch: PropTypes.func.isRequired,
  };

  return WithForm;
}
