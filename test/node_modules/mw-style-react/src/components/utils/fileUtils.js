import Utils from './utils';

const FileUtils = {
  download(url, name) {
    const link = document.createElement('a');
    link.href = url;

    if (link.download !== undefined) {
      // Set HTML5 download attribute. This will prevent file from opening if supported.
      const fileName = name || url.substring(url.lastIndexOf('/') + 1, url.length);
      link.download = fileName;

      // Dispatching click event.
      if (document.createEvent) {
        const e = document.createEvent('MouseEvents');
        e.initEvent('click', true, true);
        link.dispatchEvent(e);
        return true;
      }

      // Force file download (whether supported by server).
      const query = '?download';

      window.open(url + query, '_self');
    } else {
      document.location.href = url;
    }
  },

  _promiseFileReader(file) {
    const reader = new FileReader();

    return new Promise((resolve, reject) => {
      reader.onerror = () => {
        reader.abort();
        reject(new DOMException('Problem parsing input file'));
      };
      reader.onload = () => {
        resolve(reader.result);
      };
      reader.readAsDataURL(file);
    });
  },

  async makeFilesArr(filesSource) {
    const files = [];
    for (let i = 0; i < filesSource.length; i += 1) {
      const file = filesSource[i];
      const value = await this._promiseFileReader(file);
      const fileObj = {
        id: `${i.toString()}_${Utils.random()}`,
        label: file.name,
        size: file.size,
        type: file.type,
        value,
        fileSource: file,
      };
      files.push(fileObj);
    }
    return files;
  },

  biteToSize(bites) {
    const KB = 1024;
    const MB = KB * 1024;
    if (bites >= MB) {
      return `${(bites / MB).toFixed(2)} MB`;
    } else if (bites >= KB) {
      return `${(bites / KB).toFixed(2)} KB`;
    }
    return `${bites} B`;
  }
};
export default FileUtils;
