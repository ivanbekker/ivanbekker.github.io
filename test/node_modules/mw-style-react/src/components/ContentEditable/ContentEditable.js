import PropTypes from 'prop-types';
import React, {Component} from 'react';
import injectSheet from 'react-jss';
import cn from 'clsx';
import styles from './ContentEditable.style';
import Utils from '../utils/utils';

@injectSheet(styles)
class ContentEditable extends Component {
  constructor(props) {
    super(props);
    this.emitChange = ::this.emitChange;
    this.handlePaste = ::this.handlePaste;
  }

  componentWillMount() {
    const {forwardRef} = this.props;
    this.inputRef = forwardRef || React.createRef();
  }

  // fix caret position jump to start
  shouldComponentUpdate(nextProps) {
    const inputHtml = this.inputRef.current;
    if (this._formatText(nextProps.value) !== this._formatText(inputHtml.innerHTML)) return true;
    const optional = ['placeholder', 'tabIndex', 'className', 'id'];
    return optional.some(name => this.props[name] !== nextProps[name]);
  }

// fix caret position jump to start
  componentDidUpdate() {
    const inputHtml = this.inputRef.current;
    const {value} = this.props;
    const formattedValue = this._formatText(value);
    if (inputHtml && formattedValue !== this._formatText(inputHtml.innerHTML)) {
      inputHtml.innerHTML = formattedValue;
    }
  }

  _formatText(value) {
    const {type} = this.props;
    if (type === 'text') {
      return Utils.stripHtml(value);
    }
    return Utils.sanitizeHtml(value);
  }

  // Emit handle onChange
  emitChange(e) {
    const inputHtml = this.inputRef.current;
    if (!inputHtml) return;
    const html = e.target.innerHTML;
    if (html !== this.lastHtml) {
      e = Object.assign({}, e, {
        target: {value: html},
      });
      this.handleChange(e, html);
    }
    this.lastHtml = html;
  }

  handleChange(e, value) {
    const {id, onChange} = this.props;
    onChange({id, value, error: false});
  }

  handlePaste(e) {
    const {onPaste} = this.props;
    if (onPaste) {
      onPaste(e);
      return;
    }
    e.preventDefault();
    let text = e.clipboardData.getData('text/plain');
    text = Utils.stripHtml(text);
    document.execCommand('insertHTML', false, text);
  }

  render() {
    const {
      id,
      classes,
      className,
      value,
      onKeyPress,
      onKeyDown,
      onKeyUp,
      onFocus,
      onBlur,
      onDoubleClick,
      tabIndex,
      placeholder,
      visibility
    } = this.props;

    const formatValue = this._formatText(value);
    return (
      <div
        id={id}
        className={cn(className, classes.contentEdit)}
        ref={this.inputRef}
        dangerouslySetInnerHTML={{__html: formatValue}}
        contentEditable={visibility === 'visible'}
        onInput={this.emitChange}
        onFocus={onFocus}
        onBlur={onBlur}
        onKeyPress={onKeyPress}
        onKeyDown={onKeyDown}
        onKeyUp={onKeyUp}
        tabIndex={tabIndex}
        placeholder={placeholder}
        onDoubleClick={onDoubleClick}
        onPaste={this.handlePaste}
      />
    );
  }
}

ContentEditable.defaultProps = {
  visibility: 'visible',
  tabIndex: 0,
  placeholder: null,
  type: 'text',
  onChange: () => {
  },
  onFocus: () => {
  },
  onBlur: () => {
  },
  onClickRightIcon: () => {
  },
  onKeyPress: () => {
  },
  onKeyUp: () => {
  },
  onKeyDown: () => {
  },
  onDoubleClick: () => {
  }
};

ContentEditable.propTypes = {
  classes: PropTypes.object,
  /** additional external class name */
  className: PropTypes.string,
  /** onChange callback */
  onChange: PropTypes.func,
  /** ContentEditable's id */
  id: PropTypes.string,
  /** ContentEditable's visibility */
  visibility: PropTypes.oneOf(['visible', 'disabled', 'hidden']).isRequired,
  /** ContentEditable's visibility */
  type: PropTypes.oneOf(['text', 'html']).isRequired,
  /** text field's value */
  value: PropTypes.string,
  /** Use that property to pass a ref callback to the native input component. */
  forwardRef: PropTypes.object,
  /** onDoubleClick callback */
  onDoubleClick: PropTypes.func,
  /** onKeyPress callback */
  onKeyPress: PropTypes.func,
  /** onKeyUp callback */
  onKeyUp: PropTypes.func,
  /** onKeyDown callback */
  onKeyDown: PropTypes.func,
  /** onFocus callback */
  onFocus: PropTypes.func,
  /** onBlur callback */
  onBlur: PropTypes.func,
  /** onPaste callback */
  onPaste: PropTypes.func,
  /** Tab index */
  tabIndex: PropTypes.number,
  /** placeholder */
  placeholder: PropTypes.string,
};

export default ContentEditable;
