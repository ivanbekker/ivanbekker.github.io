import PropTypes from 'prop-types';
import ReactDOM from 'react-dom';
import React, {PureComponent} from 'react';
import injectSheet from 'react-jss';
import cn from 'clsx';
import enhanceWithClickOutside from 'react-click-outside';
import Label from '../Label';
import Utils from '../utils/utils';
import styles from './Autocomplete.style';

@injectSheet(styles)
@enhanceWithClickOutside
class Autocomplete extends PureComponent {
  constructor(props) {
    super(props);
    this.state = {
      selected: !!props.value,
      passShow: false,
      focus: false,
      error: !!props.value,
      activeItem: -1,
    };
    this.handleChange = ::this.handleChange;
    this.handleFocus = ::this.handleFocus;
    this.handleKeyDown = ::this.handleKeyDown;
    this.handleMouseMove = ::this.handleMouseMove;
    this.handleClickRightText = ::this.handleClickRightText;
  }

  componentDidMount() {
    const {autoFocus} = this.props;
    if (autoFocus) this.handleFocus();
  }

  // Handler for click outside of component
  handleClickOutside(e) {
    if (this.txtEl && this.txtEl.contains(e.target)) return;
    const {id, value, error, onBlur, onChange} = this.props;
    if (!value && !this.input.value) {
      this.setState({selected: false});
    }
    this.setState({focus: false});
    if (value && value !== value.trim()) {
      onChange({id, value: value.trim(), error});
    }
    onBlur();
  }

  componentWillReceiveProps(nextProps) {
    if (this.props.value !== nextProps.value) {
      this.setState({selected: !!nextProps.value});
    }
  }

  handleFocus() {
    const {visibility, onFocus} = this.props;
    if (visibility !== 'visible') return;
    this.input.focus();
    this.setState({selected: true, focus: true});
    onFocus(this.props.id);
  }

  handleChange(e) {
    const {id, onChange} = this.props;
    const {error, value} = this.formatAndCheck(e.target.value);
    onChange({id, value, error});
  }

  handleKeyDown(e) {
    const {value, onKeyDown} = this.props;
    const hotKeys = ['ArrowDown', 'ArrowUp', 'Enter'];
    // delete
    if (e.key === 'Backspace' && value === '') {
      this.removeChip();
    }
    if (hotKeys.indexOf(e.key) !== -1) {
      this.selectionUsingButtons(e);
    }
    onKeyDown(e);
  }

  handleClickRightText() {
    const {onClickRightText} = this.props;
    onClickRightText();
  }

  removeChip() {
    const children = this.props.chipsItems();
    if (children.length === 0) return;
    this[`chipRef${children.length - 1}`].props.closeClick();
  }

  selectionUsingButtons(e) {
    e.preventDefault();

    const children = this.props.searchResult();
    if (!children) return;

    const childrenList = children.props.children;
    const {activeItem} = this.state;
    let newActiveItem = activeItem;

    if (e.key === 'ArrowDown' && activeItem < childrenList.length - 1) {
      newActiveItem += 1;
    } else if (e.key === 'ArrowUp' && activeItem > 0) {
      newActiveItem -= 1;
    }

    if (!childrenList[newActiveItem]) return;
    const item = this[`itemRef${childrenList[newActiveItem].props.id}`];

    if (e.key === 'Enter') {
      const {id, value, avatar, visibility} = item.props;
      if (visibility === 'disabled') return;
      item.props.onClick({id, value, avatar, error: false});
      newActiveItem = 0;
    }

    this.setState(
      {
        activeItem: newActiveItem,
      },
      this.scrollList(ReactDOM.findDOMNode(item)),
    );
  }

  scrollList(item) {
    const container = ReactDOM.findDOMNode(this.containerSearchList);
    const heightContainer = container.offsetHeight;
    const heightItem = item.offsetHeight;
    const scrollPosition =
      item.offsetTop < heightContainer - heightItem * 3
        ? 0
        : item.offsetTop - (heightContainer - heightItem * 3);

    Utils.scrollTo(container, scrollPosition, 100);
  }

  formatAndCheck(value) {
    let error = false;
    const {length, required} = this.props;
    if (!value.length) {
      return {error, value};
    }
    // Restriction by string length
    if (length && value.length >= length) {
      value = value.substr(0, length);
    }
    if (required && (!value || !value.length)) {
      error = true;
    }
    return {error, value};
  }

  renderChips(chipsItems) {
    const children = chipsItems();
    if (!children) return null;
    return React.Children.map(children, (child, index) =>
      React.cloneElement(child, {
        ref: el => {
          this[`chipRef${index}`] = el;
        },
      }),
    );
  }

  renderRightText(text, classes) {
    if (!text) return null;
    return <Label value={text} className={classes} onClick={this.handleClickRightText}/>;
  }

  renderHelperText(helperText, classes) {
    if (!helperText) return null;
    return <div className={classes}>{helperText}</div>;
  }

  handleMouseMove() {
    const {activeItem} = this.state;
    if (activeItem !== -1) {
      this.setState({
        activeItem: -1,
      });
    }
  }

  renderSearchList(searchTitle, searchResult, classes) {
    const children = searchResult();
    const title = searchTitle();
    const index = this.state.activeItem;
    if (!children) return null;
    return (
      <div
        className={cn(classes, 'searchList')}
        onMouseMove={this.handleMouseMove}
        ref={el => {
          this.containerSearchList = el;
        }}
      >
        {title}
        {React.Children.map(children.props.children, child => {
          const activeItem = children.props.children[index]
            ? children.props.children[index].props.id
            : null;

          return React.cloneElement(child, {
            ref: el => {
              this[`itemRef${child.props.id}`] = el;
            },
            activeItem,
          });
        })}
      </div>
    );
  }

  render() {
    const {
      classes,
      className,
      id,
      value,
      visibility,
      label,
      error,
      placeholder,
      helperText,
      rightText,
      onKeyUp,
      onKeyPress,
      chipsItems,
      searchTitle,
      searchResult,
    } = this.props;
    const {focus, selected} = this.state;
    const tabIndex = visibility !== 'visible' ? -1 : 0;
    const txtClasses = cn(
      className,
      classes.txt,
      {error: !!error},
      {hidden: visibility === 'hidden'},
      {disabled: visibility === 'disabled'},
      {focus: !!focus},
      {selected: !!selected || chipsItems},
    );
    const helperTextClasses = cn(classes.helperText, {error});
    const searchListClasses = classes.searchList;
    const rightTextClasses = cn(classes.rightText, 'rightText');
    const chipsClasses = 'chipsContainer';

    return (
      <div
        id={id}
        className={txtClasses}
        ref={el => {
          this.txtEl = el;
        }}
        onClick={this.handleFocus}
      >
        <div className={classes.label}>{label}</div>
        <div className={classes.field}>
          <div className={classes.fieldInput}>
            {this.renderChips(chipsItems, chipsClasses)}
            <input
              ref={el => (this.input = el)}
              value={value}
              onFocus={this.handleFocus}
              onChange={this.handleChange}
              autoComplete="off"
              disabled={visibility === 'disabled'}
              tabIndex={tabIndex}
              placeholder={placeholder}
              onKeyPress={onKeyPress}
              onKeyDown={this.handleKeyDown}
              onKeyUp={onKeyUp}
            />
          </div>
          {this.renderRightText(rightText, rightTextClasses)}
        </div>
        {this.renderHelperText(helperText, helperTextClasses)}
        {this.renderSearchList(searchTitle, searchResult, searchListClasses)}
      </div>
    );
  }
}

Autocomplete.defaultProps = {
  visibility: 'visible',
  error: false,
  chipsItems: null,
  searchResult: null,
  onChange: () => {
  },
  onFocus: () => {
  },
  onBlur: () => {
  },
  onClickRightText: () => {
  },
  onKeyPress: () => {
  },
  onKeyUp: () => {
  },
  onKeyDown: () => {
  },
  searchTitle: () => {
  },
};

Autocomplete.propTypes = {
  classes: PropTypes.object,
  /** autocomplet's visibility */
  visibility: PropTypes.oneOf(['visible', 'disabled', 'hidden']).isRequired,
  /** Does autocomplet's's has an error */
  error: PropTypes.bool.isRequired,
  /** autocomplet's helper text under input */
  helperText: PropTypes.string,
  /** autocomplet's label */
  label: PropTypes.string,
  /** Is autocomplete required? */
  required: PropTypes.bool,
  /** autocomplet's value */
  value: PropTypes.string,
  /** autocomplet's length */
  length: PropTypes.number,
  /** autocomplet's right text */
  rightText: PropTypes.string,
  /** placeholder */
  placeholder: PropTypes.string,
  /** input autoFocus */
  autoFocus: PropTypes.bool,
  /** additional external class name */
  className: PropTypes.string,
  /** element id */
  id: PropTypes.string,
  /** onChange callback */
  onChange: PropTypes.func,
  /** onFocus callback */
  onFocus: PropTypes.func,
  /** onBlur callback */
  onBlur: PropTypes.func,
  /** onKeyPress callback */
  onKeyPress: PropTypes.func,
  /** onKeyUp callback */
  onKeyUp: PropTypes.func,
  /** onKeyDown callback */
  onKeyDown: PropTypes.func,
  /** onClickRightIcon callback */
  onClickRightText: PropTypes.func,
  /** chipsItems */
  chipsItems: PropTypes.func,
  /** search Title */
  searchTitle: PropTypes.func,
  /** searchResult */
  searchResult: PropTypes.func,
};

export default Autocomplete;
