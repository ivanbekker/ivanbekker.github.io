import PropTypes from 'prop-types';
import React, {PureComponent} from 'react';
import injectSheet from 'react-jss';
import cn from 'clsx';
import Utils from '../utils/utils';
import styles from './Pagination.style';
import Icon from '../Icon';

const DOTS = '...';

@injectSheet(styles)
class Pagination extends PureComponent {
  correctSize(size) {
    return Number(size) || 0;
  }

  correctLimit(limit) {
    return Number(limit) || 1;
  }

  correctValue(value, paginationSize) {
    let corValue = Number(value);
    if (!corValue) return 0;
    if (corValue < 1) {
      corValue = 1;
    } else if (corValue > paginationSize) {
      corValue = paginationSize;
    }
    return corValue;
  }

  // Замена {range}, {size} в label
  replaceLabelVars(value, size, limit, label) {
    let replacedLabel = Utils.stripHtml(label);
    // Дипазон отображаемых элеметов
    if (replacedLabel.includes('{range}')) {
      const rangeStart = (value - 1) * limit + 1;
      const rangeEnd = value * limit < size ? value * limit : size;
      // выделяем range semibold
      const range = `<span class="range">${rangeStart}-${rangeEnd}</span>`;
      replacedLabel = replacedLabel.replace('{range}', range);
    }
    // Общее количество элементов
    if (replacedLabel.includes('{size}')) {
      replacedLabel = replacedLabel.replace('{size}', size);
    }
    return replacedLabel;
  }

  // Обработчик клика на элементе или иконках
  handleClick(itemValue, value) {
    const {id, onChange, visibility} = this.props;
    if (visibility === 'disabled' || itemValue === value || itemValue === DOTS) {
      return;
    }
    const error = false;
    onChange({id, value: itemValue, error});
  }

  // Создаем элемент пагинации
  getPageElement(itemValue, value) {
    const {classes} = this.props;
    return (
      <div
        key={Utils.random()}
        className={cn(classes.item, {active: itemValue === value}, {disabled: itemValue === DOTS})}
        onClick={() => this.handleClick(itemValue, value)}
      >
        {itemValue}
      </div>
    );
  }

  // Формируем элементы пагинации и рендерим
  renderPagination(value, paginationSize) {
    const pagination = [];
    if (!value || !paginationSize) return pagination;
    const maxPagesShown = 9;
    let items;

    if (paginationSize <= maxPagesShown) {
      items = Utils.range(1, paginationSize);
    } else {
      const startSubSet = [1];
      const endSubSet = [paginationSize];
      const startLimit = value + 1 <= paginationSize ? value - 2 : paginationSize - 2;
      const endLimit = value - 1 > 0 ? value + 2 : 3;
      const mainSubSet = Utils.range(startLimit, endLimit).filter(
        i => i > 0 && i <= paginationSize,
      );
      items = [...new Set([...startSubSet, ...mainSubSet, ...endSubSet])];
    }

    let prevPage = 0;
    items.forEach(page => {
      if (page - 1 !== prevPage) {
        pagination.push(this.getPageElement(DOTS, value));
      }
      pagination.push(this.getPageElement(page, value));
      prevPage = page;
    });
    return pagination;
  }

  render() {
    const {classes, className, id, visibility, value, size, limit, label} = this.props;
    const corSize = this.correctSize(size);
    const corLimit = this.correctLimit(limit);
    const paginationSize = Math.ceil(corSize / corLimit); // Количество элеметов пагинации
    const corValue = this.correctValue(value, paginationSize);

    return (
      <div
        id={id}
        className={cn(
          className,
          classes.container,
          {hidden: visibility === 'hidden'},
          {disabled: visibility === 'disabled'},
        )}
      >
        <div
          className={classes.label}
          dangerouslySetInnerHTML={{
            __html: this.replaceLabelVars(corValue, corSize, corLimit, label),
          }}
        />
        {paginationSize > 1 ?
          <div className={cn(classes.pagination, {hidden: corSize === 0 || corValue === 0})}>
            <div className={cn(classes.iconContainer, classes.iconPrev)}>
              <Icon
                className={cn(classes.icon, {
                  hidden: corValue === 1,
                })}
                type="dropdown"
                size="micro"
                color="currentColor"
                onClick={() => this.handleClick(corValue - 1, corValue)}
              />
            </div>
            {this.renderPagination(corValue, paginationSize)}
            <div className={cn(classes.iconContainer, classes.iconNext)}>
              <Icon
                className={cn(classes.icon, {
                  hidden: corValue === paginationSize,
                })}
                type="dropdown"
                size="micro"
                color="currentColor"
                onClick={() => this.handleClick(corValue + 1, corValue)}
              />
            </div>
          </div>
          : null}
      </div>
    );
  }
}

Pagination.defaultProps = {
  visibility: 'visible',
  value: '1',
  onChange: () => {
  },
  label: '{range} / {size}',
};

Pagination.propTypes = {
  classes: PropTypes.object,
  /** Pagination's visibility */
  visibility: PropTypes.oneOf(['visible', 'disabled', 'hidden']),
  /** Pagination's id */
  id: PropTypes.string,
  /** additional external class name */
  className: PropTypes.string,
  /** All elements count */
  size: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired,
  /** Elements view limit */
  limit: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired,
  /** Pagination's label string template,
   * need use vars {range} and {size} */
  label: PropTypes.string,
  /** Pagination's value */
  value: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  /** Pagination's callback */
  onChange: PropTypes.func,
};

export default Pagination;
