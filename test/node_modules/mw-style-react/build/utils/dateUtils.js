'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var DateUtils = {

  // Получить unixtime на сейчас
  unixtime: function unixtime() {
    return Math.floor(new Date().getTime() / 1000);
  },


  // Привести дату к началу периода
  startOf: function startOf(date, condition) {
    var newDate = new Date(date);
    switch (condition) {
      case 'day':
        newDate.setHours(0, 0, 0, 0);
        break;
      case 'week':
        var first = date.getDate() - date.getDay() + 1;
        newDate.setDate(first);
        newDate.setHours(0, 0, 0, 0);
        break;
      default:
        throw new Error('Unsupported condition "' + condition + '"');
    }
    return newDate;
  },


  // Привести дату к концу периода
  endOf: function endOf(date, condition) {
    var newDate = new Date(date);
    switch (condition) {
      case 'day':
        newDate.setHours(23, 59, 59, 0);
        break;
      case 'week':
        var first = date.getDate() - date.getDay() + 1;
        var last = first + 6;
        newDate.setDate(last);
        newDate.setHours(23, 59, 59, 0);
        break;
      default:
        throw new Error('Unsupported condition "' + condition + '"');
    }
    return newDate;
  },


  // Получить unixtime конкретной даты
  dateToUnixtime: function dateToUnixtime(date) {
    return Math.floor(date.getTime() / 1000);
  },


  // Получить список месяцев
  getMonth: function getMonth(month, lang) {
    var monthNames = void 0;
    switch (lang) {
      case 'ru':
        monthNames = ['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 'Июль', 'Август', 'Сентябрь', 'Окрябрь', 'Ноябрь', 'Декабрь'];
        break;
      default:
        monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
    }
    return monthNames[month];
  },
  addZero: function addZero(num) {
    return num < 10 ? '0' + num : num;
  },


  // Полчить объект с временем
  unixtime2Date: function unixtime2Date(unixtime) {
    var mtime = +unixtime * 1000;
    var date = new Date(mtime);
    return {
      month: date.getMonth(),
      year: date.getFullYear(),
      day: date.getDate(),
      h: date.getHours(),
      m: date.getMinutes(),
      s: date.getSeconds()
    };
  },


  // Форматирование даты
  toDate: function toDate(unixtime, format) {
    var lang = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'en';

    if (!unixtime) return '-';

    var date = this.unixtime2Date(unixtime);

    switch (format) {
      case 'YYYY.MM.DD':
        return date.year + '.' + this.addZero(date.month + 1) + '.' + this.addZero(date.day);
      case 'DD M YYYY':
        return this.addZero(date.day) + ' ' + this.getMonth(date.month, lang) + ' ' + date.year;
      case 'DD m YYYY':
        return this.addZero(date.day) + ' ' + this.getMonth(date.month, lang).substr(0, 3) + ' ' + date.year;
      case 'DD M YYYY, HH:mm':
        return this.addZero(date.day) + ' ' + this.getMonth(date.month, lang) + ' ' + date.year + ', ' + date.h + ':' + this.addZero(date.m);
      case 'DD M HH:mm':
        return this.addZero(date.day) + ' ' + this.getMonth(date.month, lang) + ' ' + date.h + ':' + this.addZero(date.m);
      case 'DD m HH:mm':
        return this.addZero(date.day) + ' ' + this.getMonth(date.month, lang).substr(0, 3) + ' ' + date.h + ':' + this.addZero(date.m);
      case 'm DD, YYYY; HH:mm':
        return this.getMonth(date.month, lang).substr(0, 3) + ' ' + this.addZero(date.day) + ', ' + date.year + '; ' + date.h + ':' + this.addZero(date.m);
      case 'M DD, YYYY; HH:mm':
        return this.getMonth(date.month, lang) + ' ' + this.addZero(date.day) + ', ' + date.year + '; ' + date.h + ':' + this.addZero(date.m);
      case 'DD.MM.YY':
        return this.addZero(date.day) + '.' + this.addZero(date.month + 1) + '.' + String(date.year).slice(-2);
      case 'HH:mm:ss':
        return date.h + ':' + this.addZero(date.m) + ': ' + this.addZero(date.s);
      case 'HH:mm':
        return date.h + ':' + this.addZero(date.m);
      default:
        return unixtime;
    }
  },
  nonoSecToUnixtime: function nonoSecToUnixtime(nano) {
    return (nano / 1000000000).toFixed(0);
  },


  // Относительная дата
  relativeDate: function relativeDate(unixtime) {
    var now = this.unixtime();
    var delta = Math.round(now - unixtime);
    var minute = 60;
    var hour = minute * 60;
    var day = hour * 24;
    var month = day * 30;
    var fuzzy = void 0;

    if (delta < 30) {
      fuzzy = 'just now';
    } else if (delta < minute) {
      fuzzy = delta + ' seconds ago';
    } else if (delta < 2 * minute) {
      fuzzy = 'a minute ago';
    } else if (delta < hour) {
      fuzzy = Math.floor(delta / minute) + ' minutes ago';
    } else if (Math.floor(delta / hour) === 1) {
      fuzzy = '1 hour ago';
    } else if (delta < day) {
      fuzzy = Math.floor(delta / hour) + ' hours ago';
    } else if (delta < day * 2) {
      fuzzy = 'yesterday';
    } else if (delta < month) {
      fuzzy = Math.floor(delta / day) + ' days ago';
    } else if (Math.floor(delta / month) === 1) {
      fuzzy = 'month ago';
    } else {
      fuzzy = Math.floor(delta / month) + ' months ago';
    }
    return fuzzy;
  },
  todayStart: function todayStart() {
    return this.startOf(this.unixtime() * 1000, 'day').getTime() / 1000;
  },
  todayEnd: function todayEnd() {
    return this.endOf(this.unixtime() * 1000, 'day').getTime() / 1000;
  },
  tomorrowStart: function tomorrowStart() {
    return this.startOf((this.unixtime() + 24 * 60 * 60) * 1000, 'day').getTime() / 1000;
  },
  tomorrowEnd: function tomorrowEnd() {
    return this.endOf((this.unixtime() + 24 * 60 * 60) * 1000, 'day').getTime() / 1000;
  },
  yesterdayStart: function yesterdayStart() {
    return this.startOf((this.unixtime() - 24 * 60 * 60) * 1000, 'day').getTime() / 1000;
  },
  yesterdayEnd: function yesterdayEnd() {
    return this.endOf((this.unixtime() - 24 * 60 * 60) * 1000, 'day').getTime() / 1000;
  },
  isToday: function isToday(unixtime) {
    return unixtime >= this.todayStart() && unixtime < this.todayEnd();
  },
  isTomorrow: function isTomorrow(unixtime) {
    return unixtime >= this.tomorrowStart() && unixtime < this.tomorrowEnd();
  },
  isYesterday: function isYesterday(unixtime) {
    return unixtime >= this.yesterdayStart() && unixtime < this.yesterdayEnd();
  }
};

exports.default = DateUtils;