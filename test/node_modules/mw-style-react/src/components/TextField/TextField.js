import PropTypes from 'prop-types';
import React, {PureComponent} from 'react';
import injectSheet from 'react-jss';
import cn from 'clsx';
import enhanceWithClickOutside from 'react-click-outside';
import Icon from '../Icon';
import ContentEditable from '../ContentEditable';
import forwardRef from '../HOC/forwardRef';
import styles from './TextField.style';

const ContentEditCom = forwardRef(ContentEditable);

@injectSheet(styles)
@enhanceWithClickOutside
class TextField extends PureComponent {
  constructor(props) {
    super(props);
    this.state = {
      selected: !!props.value,
      passShow: false,
      focus: false,
      error: !!props.value,
    };
    this.togglePass = ::this.togglePass;
    this.handleFocus = ::this.handleFocus;
    this.handleChange = ::this.handleChange;
    this.handleBlur = ::this.handleBlur;
    this.handleChangeMult = ::this.handleChangeMult;
  }

  componentWillMount() {
    const {forwardRef} = this.props;
    this.inputRef = forwardRef || React.createRef();
  }

  componentDidMount() {
    const {autoFocus} = this.props;
    if (autoFocus) this.handleFocus();
  }

  // Получить value поля ввода
  getInputElValue() {
    const {multiline} = this.props;
    return multiline ? this.inputRef.innerHTML : this.inputRef.value;
  }

  // Handler for click outside of component
  handleClickOutside(e) {
    if (this.txtEl && this.txtEl.contains(e.target)) return;
    const {id, value, error, type, onBlur, onChange, calendar} = this.props;
    const {focus} = this.state;
    if (!value && !this.getInputElValue()) {
      this.setState({selected: false});
    }
    if (focus && !calendar) {
      this.setState({focus: false});
    }
    // trim value for all types except 'password'
    if (value && type !== 'password' && value !== value.trim()) {
      onChange({id, value: value.trim(), error});
    }
    onBlur();
  }

  componentWillReceiveProps(nextProps) {
    if (this.props.value !== nextProps.value) {
      this.setState({selected: !!nextProps.value});
    }
  }

  // get input type
  getInputType(type, passShow) {
    return type === 'password' && !passShow ? 'password' : 'text';
  }

  // focus for field
  handleFocus() {
    const {visibility, onFocus, id} = this.props;
    if (visibility !== 'visible') return;
    this.inputRef.current.focus();
    this.setState({selected: true, focus: true});
    onFocus(id);
  }

  // blur for field
  handleBlur() {
    const {calendar, value, visibility, onBlur, id} = this.props;
    if (visibility !== 'visible') return;
    if (!calendar) {
      this.setState({
        selected: Boolean(value) || false,
        focus: false,
      });
    }
    onBlur(id);
  }

  // Handle change for single line field
  handleChange(e) {
    const {id, onChange} = this.props;
    const {error, value} = this.formatAndCheck(e.target.value);
    onChange({id, value, error});
  }

  // Handle change for multiple line field
  handleChangeMult({value: multVal}) {
    const {id, onChange} = this.props;
    const {error, value} = this.formatAndCheck(multVal);
    onChange({id, value, error});
  }

  formatAndCheck(value) {
    let error = false;
    const {regexp, type, length, required} = this.props;

    if (type === 'email') {
      // eslint-disable-next-line max-len
      const re = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
      if (!re.test(String(value))) {
        error = true;
      }
    }
    // Formatting type int
    if (type === 'int' || (type === 'phone' && /\D/g.test(value))) {
      value = value.replace(/\D/g, '');
    }
    // Formatting type float
    if (type === 'float') {
      value = value.replace(/[^0-9.]/g, '').replace(/(\..*)\./g, '$1');
    }
    // Restriction by string length
    if (length && value.length >= length) {
      value = value.substr(0, length);
    }
    // check regexp
    if (regexp) {
      const r = new RegExp(regexp);
      error = !r.test(value.trim());
    }
    if (required && (!value || !value.length)) {
      error = true;
    }
    return {error, value};
  }

  // show/hide password
  togglePass() {
    const {passShow} = this.state;
    this.setState({passShow: !passShow});
  }

  handleClickRightIcon() {
    const {onClickRightIcon, id} = this.props;
    onClickRightIcon(id);
  }

  // Render fake input fields for disabling browser autocomplete
  renderFakePass() {
    if (this.props.type !== 'password') return null;
    return (
      <div style={{display: 'none'}}>
        <input type="text"/>
        <input type="password"/>
      </div>
    );
  }

  // render icon on the left side
  renderIcon(icon, classes, position, error, handleClick) {
    if (!icon) return null;
    const {size, bordered} = this.props;
    return (
      <div className={cn(classes[position], position)}>
        <Icon
          type={icon}
          error={error}
          onClick={handleClick}
          size={bordered && size === 'small' ? 'small' : 'medium'}
        />
      </div>
    );
  }

  // render show\hide password button for text field's type password
  renderShowPassBtn(type, passShow, classes) {
    if (type !== 'password') return null;
    const {size, bordered} = this.props;
    const iconType = passShow ? 'no_eye' : 'eye';
    return (
      <Icon
        type={iconType}
        size={bordered && size === 'small' ? 'small' : 'medium'}
        className={classes.passIcon}
        onClick={this.togglePass}
      />
    );
  }

  // render error message
  renderHelperText(error, helperText, classes) {
    if (!helperText) return null;
    return <div className={cn(classes.helperText, {error})}>{helperText}</div>;
  }

  // Отрисовать Calendar
  renderCalendar(Calendar, classes) {
    const {focus} = this.state;
    const {onBlur} = this.props;
    let top = 10;
    if (this.field && window.innerHeight - this.field.offsetTop < 380) {
      top = window.innerHeight - this.field.offsetTop - 380;
    }

    if (focus && Calendar) {
      const calendar = Calendar();
      return (
        <div className={cn(classes.calendar)} style={{top}}>
          {React.cloneElement(calendar, {
            onClose: () => {
              this.setState({focus: false});
              onBlur();
            },
          })}
        </div>
      );
    }
  }

  // Отрисовать placeholder
  renderPlaceholder() {
    const {placeholder, size, label, bordered} = this.props;
    const {selected} = this.state;
    if (!placeholder) return null;
    if (size === 'small' || selected || (!label && !selected) || bordered) return placeholder;
  }

  // Отрисовать однострочное поле ввода
  renderInput() {
    const {type, visibility, value, onKeyPress, onKeyUp, onKeyDown} = this.props;
    const {passShow} = this.state;
    const tabIndex = visibility !== 'visible' ? -1 : 0;

    return (
      <input
        ref={this.inputRef}
        type={this.getInputType(type, passShow)}
        value={value}
        onClick={this.handleFocus}
        onChange={this.handleChange}
        autoComplete="off"
        disabled={visibility === 'disabled'}
        tabIndex={tabIndex}
        placeholder={this.renderPlaceholder()}
        onKeyPress={onKeyPress}
        onKeyDown={onKeyDown}
        onKeyUp={onKeyUp}
        onBlur={this.handleBlur}
      />
    );
  }

  // Отрисовать многострочное поле ввода
  renderMultiline() {
    const {id, visibility, value, onKeyPress, onKeyUp, onKeyDown} = this.props;
    const tabIndex = visibility !== 'visible' ? -1 : 0;

    return (
      <ContentEditCom
        id={id}
        ref={this.inputRef}
        type="html"
        visibility={visibility}
        onFocus={this.handleFocus}
        onChange={this.handleChangeMult}
        onKeyPress={onKeyPress}
        onKeyDown={onKeyDown}
        onKeyUp={onKeyUp}
        tabIndex={tabIndex}
        placeholder={this.renderPlaceholder()}
        value={value}
        onBlur={this.handleBlur}
      />
    );
  }

  // Отрисовать label
  renderLabel() {
    const {label, size, bordered, classes} = this.props;
    if (!bordered && size === 'small') return null;
    return (
      <div className={cn(classes.label, 'label')} onClick={this.handleFocus}>
        {label}
      </div>
    );
  }

  render() {
    const {
      classes,
      className,
      id,
      type,
      size,
      visibility,
      error,
      rightIcon,
      helperText,
      calendar,
      multiline,
      bordered,
    } = this.props;
    const {passShow, focus, selected} = this.state;
    let leftIcon = type === 'phone' ? 'plus' : this.props.leftIcon;
    leftIcon = calendar ? 'calendar' : leftIcon;

    return (
      <div
        id={id}
        className={cn(
          className,
          classes.txt,
          classes[size],
          {error: !!error},
          {hidden: visibility === 'hidden'},
          {disabled: visibility === 'disabled'},
          {focus: !!focus},
          {selected: !!selected},
          {hasLeftIcon: !!leftIcon},
          {bordered},
        )}
        ref={el => {
          this.txtEl = el;
        }}
      >
        {this.renderLabel()}
        <div
          className={cn(classes.field, 'field')}
          onClick={this.handleFocus}
          ref={el => {
            this.field = el;
          }}
        >
          {this.renderIcon(leftIcon, classes, 'leftIcon', error)}
          {multiline ? this.renderMultiline() : this.renderInput()}
          {this.renderIcon(
            rightIcon,
            classes,
            'rightIcon',
            error,
            this.handleClickRightIcon.bind(this),
          )}
          {this.renderShowPassBtn(type, passShow, classes)}
          {this.renderFakePass()}
        </div>
        {this.renderHelperText(error, helperText, classes)}
        {this.renderCalendar(calendar, classes)}
      </div>
    );
  }
}

TextField.defaultProps = {
  type: 'text',
  size: 'medium',
  visibility: 'visible',
  error: false,
  location: 'en',
  calendar: null,
  multiline: false,
  onChange: () => {
  },
  onFocus: () => {
  },
  onBlur: () => {
  },
  onClickRightIcon: () => {
  },
  onKeyPress: () => {
  },
  onKeyUp: () => {
  },
  onKeyDown: () => {
  },
  bordered: false,
};

TextField.propTypes = {
  classes: PropTypes.object,
  /** text field's type */
  type: PropTypes.oneOf(['text', 'password', 'phone', 'email', 'int', 'float']),
  /** text field's size */
  size: PropTypes.oneOf(['small', 'medium', 'large']),
  /** text field's visibility */
  visibility: PropTypes.oneOf(['visible', 'disabled', 'hidden']),
  /** Does text field's has an error */
  error: PropTypes.bool,
  /** text field's helper text under input */
  helperText: PropTypes.string,
  /** text field's label */
  label: PropTypes.string,
  /** Is text field required? */
  required: PropTypes.bool,
  /** text field's value */
  value: PropTypes.string,
  /** text field's regular expression */
  regexp: PropTypes.string,
  /** text field's length */
  length: PropTypes.number,
  /** text field's left icon */
  leftIcon: PropTypes.string,
  /** text field's right icon */
  rightIcon: PropTypes.string,
  /** placeholder */
  placeholder: PropTypes.string,
  /** input autoFocus */
  autoFocus: PropTypes.bool,
  /** additional external class name */
  className: PropTypes.string,
  /** element id */
  id: PropTypes.string,
  /** onChange callback */
  onChange: PropTypes.func,
  /** onFocus callback */
  onFocus: PropTypes.func,
  /** onBlur callback */
  onBlur: PropTypes.func,
  /** onKeyPress callback */
  onKeyPress: PropTypes.func,
  /** onKeyUp callback */
  onKeyUp: PropTypes.func,
  /** onKeyDown callback */
  onKeyDown: PropTypes.func,
  /** onClickRightIcon callback */
  onClickRightIcon: PropTypes.func,
  /** Calendar */
  calendar: PropTypes.func,
  /** multiline field */
  multiline: PropTypes.bool,
  /** Use that property to pass a ref callback to the native input component. */
  forwardRef: PropTypes.object,
  /** bordered field */
  bordered: PropTypes.bool,
};

export default TextField;
